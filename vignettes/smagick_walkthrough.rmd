---
title: "`smagick`: Magical string interpolation"
author: "Laurent R. Berge"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{smagick_walkthrough}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

String interpolation is a common feature of many programming languages and is
used to insert the value of variables directly into character strings.
This is useful to compose dynamic messages in a natural way. For example
`"Hello {x}"` will be interpolated as "Hello John" if `x = "John"`.
hahahaha 
What if you want to apply some modifications to the variable before insertion?
Like normalizing the case, trimming at 40 characters, or concatenating? 
In general, you can't. Well, actually you can but have to use the language's own native tools. 
And it can be surprising how performing a few basic operations can quickly amount to lot of typing.

The aim of the package `stringmagick` is to simplify and empower string interpolation. 
With the `smagick` function, you can apply 50+ basic operations to interpolated variables, 
interpolations can be nested, there is advanced support for pluralization, and much more.

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  collapse = TRUE, 
  comment = "#>"
)
```

# Motivating example

# Basic interpolation

To interpolate a variable, say `x`, simply use `{x}`. 

```{r hello-world}
x = "world"
smagick("hello {x}")
```

As we can see, anything in curly brackets gets interpolated. This behavior is similar
to the well known function [glue](https://glue.tidyverse.org/) from the tidyverse.

Now let's come to what `smagick` really brings to the table.

# Interpolation with operations: Principle

To any interpolation you can add operations. Let's take the example of the previous section and 
say we want to display "hello W O R L D". 
This means upper casing all letters of the interpolated variable and adding a space between 
each of them. Let's do it:

```{r hw-ops}
smagick("hello {upper, ''s, c ? x}")
```

Now let's explain what happened. Within the `{}` *box*, we first write a set of 
operations, here "upper, ''s, c", then add "?" and finally write 
the variable to interpolate, "x".  The operations (detailed in [the reference section](#sec_operations_reference))) 
are `upper`, upper-casing all letters, `''s`: splitting
with the empty string, `c`: concatenating with spaces the string vector that was just split.
The question mark means that the expression coming after it is to be evaluated 
(this is opposed to the exclamation mark presented in the next section).

The syntax is always the same: `{operations ? expression}`, where the operations section
is a *comma separated* list of operations.
These operations are of the form `'arg'op`, with `arg` the argument to the operator 
code `op`. These operations are performed sequentially from left to right.

Some operations, like `upper`, accept options. You attach options to an operation 
with a dot followed by the option name. Formally: `op.option1.option2`, etc. Example:

```{r ex-ops}
x = "hi there. what's up? fine."
smagick("He said: {upper.sentence, Q ? x}")
```

Both operators and options are partially matched. So `smagick("He said: {up.s, Q ? x}")` would 
also work. You have more details on the operations syntax in the [syntax section](#sec_syntax). 

# Verbatim interpolation and nesting: Principle

Instead of interpolating a variable, say `x`, with `{x}`, you can use an exclamation 
mark to trigger varbatim evaluation. For example `smagick("hello {!x}")` would lead to "hello x".
Please hold on a little bit to see the point.

Verbatim evaluation is a powerful way to apply operations to plain text. For example:

```{r}
smagick("hello {upper, ''s, c ! world}")
```

Before moving on, a necessary detail. The spaces surrounding the exclamation mark are non necessary,
but when one space is present on both sides of the `!`, then the verbatim
expression only begins after the space. Ex: `"{upper! hi}"` leads to " HI" while `"{upper ! hi}"` 
leads to "HI" and `"{upper !  hi}"` leads to " HI".

The main advantage, and real power, of verbatim evaluations is *nesting*. Anything in a verbatim 
expression becomes evaluated with the function `smagick`.
This means that any *box* will be evaluated as previously described. 

Let's give an example. You want to write the expression of a polynomial of order n: a + bx + cx^2 + etc.
You can do that with nesting:

```{r}
n = 2
smagick("poly({n}): {' + 'c ! {letters[1 + 0:n]}x^{0:n}}")
```

How does it work? The verbatim expression (the one following the exclamation mark),
here `"{letters[1 + 0:n]}x^{0:n}"`, is evaluated with `smagick`.
`smagick("{letters[1 + 0:n]}x^{0:n}")` leads to the vector `c("ax^0", "bx^1", "cx^2")`.

The operation `' + 'c` then concatenates (or collapses) that vector with ' + '.
This value is then appended to the previous string.

We could refine by adding a cleaning operation in which we replace "x^0" and "^1" 
by the empty string. Let's do it:

```{r}
n = 4
smagick("poly({n}): {' + 'c, 'f/x^0, ^1'clean ! {letters[1 + 0:n]}x^{0:n}}")
```

We obtain the desired result. 
Note that the `clean` operation is explained in the [operations reference section](#sec_operations_reference).

# Regular operations: General syntax {#sec_syntax}

As seen in the previous sections, within a *box* (i.e. `"{}"`), 
multiple operations can be performed.
We can do so by stacking the operations codes and in a comma separated enumeration.
Operations can have arguments, and operations can also have options. The general 
syntax, with argument and options, is:

```{r, eval=FALSE}
smagick("{'arg1'op1.optionA.optionB, arg2 op2.optionC, `arg3`op3, 51op4, op5 ? x}")
```

You can include arguments in four different ways:

1. inside single or double quotes just before the operation name (`arg1` above), 
1. verbatim, separated with a space, just before the operation name (`arg2` above), 
1. inside bactick quotes the argument is evaluated from the environment (`arg3` above),
1. when the argument is an integer it can be juxtaposed to the opeation name (like in `op4` above).

The options are always dot separated and attached to the operation name, they are 
specific to each operation.

Both the operation name and the option names are partially matched.

Here are examples for each types of arguments:
```{r}
# quoted argument
smagick("y = {'x'paste, ' + 'c ? 1:2}")

# verbatim argument, space separated
smagick("y = {x paste, ' + 'c ? 1:2}")

# evaluated argument
x = "z"
smagick("y = {`x`paste, ' + 'c ? 1:2}")

# digits accolated to the operator
smagick("y = {0paste, ' + 'c ? 1:2}")

# options bq (back quote) and a to operator enum
smagick("y = the sum of {'x'paste, enum.bq.a ? 1:2}")
```

A few operators have two arguments. Pass multiple arguments using a pipe as follows:
```{r}
smagick("{'arg1|arg2'op, 'arg1||arg2'op ? x}")
```
You can escape the meaning of the pipe as a separator with a double backslash. 
Some operators accept a double pipe which modifies the behavior of the second argument.
Here is an example:
```{r}
x = "Quels sont ces serpents qui sifflent sur vos têtes?"
# let's shorten this
smagick("Oreste: {s, '4|..'k, c, Q ? x}")

rome = c("Rome qui t'a vu naître et que ton coeur adore",
         "Rome enfin, que je hais parce qu'elle t'honore!")
# the double pipe triggers a different behavior in this operator
smagick("Camille: {s, '4||..'k, c, Q ? rome}")
```

# Regular operations: Reference {#sec_operations_reference}

This section references all `smagick`'s regular operations.

## Basic string operations

This section describes some of the most common string operations: extracting, replacing, collapsing, splitting, etc.
These functions accept generic flags ("ignore", "fixed", "word") in their patterns (syntax: "flags/pattern"). 
Please see the dedicated section for more information on flags.

- s, S: splits the string according to a pattern. The two operations have different defaults: `' '` 
for `s` and `',[ \t\n}*'` for `S` (i.e. comma separation). 
```{r}
# 'S' with its default (comma separation)
smagick("{S ! romeo, juliet}")
# result with 's' is different
smagick("{s ! romeo, juliet}")
# with argument: 's' and 'S' are identical
# note the flag 'fixed' (`f/`) to remove regex interpretation
smagick("{'f/+'s, '-'c ! 5 + 2} = 3")
```

+ c, C: to concatenate multiple strings into a single one. The two operations are 
identical, only their default change. c: default is `' '`, C: default is `', | and '`.
The syntax of the argument is 's1' or 's1|s2'. s1 is the string used to concatenate 
(think `paste(x, collapse = s1)`). In arguments of the form `'s1|s2'`, `s2` will be 
used to concatenate the last two elements. 
When the elements of the vector are split, each original item is kept in memory 
so that group-wise operations can be applied. See the section on group-wise operations.

```{r}
# regular way
x = 1:4
smagick("And {' and 'c ? x}!")

# with s2
smagick("Choose: {', | or 'c ? 2:4}?")

# default of C: enumeration
wines = c("Saint-Estephe", "Margaux")
smagick("I like {C?wines}.")

# default of c: space concatenation
smagick("{s, '.{5,}'get, c ! I don't like short words}")
```

+ extract: extracts multiple patterns from a string, this is an alias to the operation `X` described below.
Default argument is `'[[:alnum:]]+'`.
Use the option "first" to extract only the first match for each string (behavior becomes like `x`). 
When patterns are extracted, each original item is kept in memory 
so that group-wise operations can be applied. See the section on group-wise operations.
```{r}
x = c("margo: 32, 1m75", "luke doe: 27, 1m71")
smagick("{'^\\w+'extract ? x} is {'\\d+'extract.first ? x}")

# illustrating multiple extractions
# conditional operation (~()) is detailed in its own section
x = c("Combien de marins, combien de capitaines.",
      "Qui sont partis joyeux pour des courses lointaines,",
      "Dans ce morne horizon se sont évanouis !")
smagick("Endings with i: {'i\\w*'extract, ~(', 'c), enum.1 ? x}.")
```

+ x, X: extracts patterns from a string. Both have the same default: `'[[:alnum:]]+'`. 
`x` extracts the first match while `X` extracts **all** the matches.

```{r}
x = c("6 feet under", "mahogany")
# single extraction
smagick("{'\\w{3}'x ? x}")
# multiple extraction
smagick("{'\\w{3}'X ? x}")
```

+ r, R: replacement within a string. The two operations are identical and have no default.
The syntax is `'old'` or `'old => new'` with `'old'` the pattern to find and `new` the 
replacement. If `new` is missing, it is 
considered the empty string. On top of regular flags, this operation also accepts 
the flag "total" which instruct to replace the fulll string in case the pattern is found.
```{r}
# regex without replacement (ie removing)
smagick("{'e'r ! Where is the letter e?}")
# regex with replacement
smagick("{'(?<!\\b)e => a'R ! Where is the letter e?}")
# we replace the full string with the flag total (`t/`)
x = c("Where is the letter e?", "Not this way!")
smagick("{'t/e => here!'r ? x}")
```

+ clean: replacement with a string. Similar to the operation `r`, except that here the comma is
a pattern separator. The argument is of the form `"flags/pattern1, pattern2 => replacement"`. 
See detailed explanations in str_clean(). 

```{r}
# we use the fixed pattern to remove the regex meaning
smagick("{'f/[, ]'clean ! x[a]}")
```

+ get: restricts the string vector to only the values respecting a pattern. This operation has no default.
Accepts the options "equal" and "in".
By default it uses the same syntax as str_get() so that you can use regex flags and 
include logical operations with `' & '` and `' | '`.
If the option "equal" is used, a simple string equality with the argument is tested (hence
no flags are accepted). If the option "in" is used, the argument is first split with respect to commas
and then set inclusion is tested. 

```{r}
x = row.names(mtcars)
#  we only keep models containing "Merc" and ending with a letter ([[:alpha:]]$)
smagick("Mercedes models: {'Merc & [[:alpha:]]$'get, '^.+ 'r, C ? x}.")

models = c("Merc 230", "Merc 450SE", "Merc 480")
# we only ekep the ones in the set
smagick("Mercedes models: {`models`get.in, C ? x}.")
```

+ is: detects if a pattern is present in a string, returns a logical vector. This operation has no default.
Mostly useful as the final operation in a str_op() call.
By default it uses the same syntax as str_is() so that you can use regex flags and 
include logical operations with `' & '` and `' | '`.
If the option "equal" is used, a simple string equality with the argument is tested (hence
no flags are accepted). If the option "in" is used, the argument is first split with respect to commas
and then set inclusion is tested. 
```{r}
x = c("Mark", "Lucas")
# note that we use the flag `i/` to ignore the case
smagick("Mark? {'i/mark'is, C ? x}")
```

+ which: returns the index of string containing a specified pattern. With no default, can be applied
to a logical vector directly. 
By default it uses the same syntax as str_which() so that you can use regex flags and 
include logical operations with `' & '` and `' | '`.
If the option "equal" is used, a simple string equality with the argument is tested (hence
no flags are accepted). If the option "in" is used, the argument is first split with respect to commas
and then set inclusion is tested. 
Mostly useful as the final operation in a str_op() call.
```{r}
x = c("Mark", "Lucas", "Markus")
# note that we use the flag `i` to ignore the case and `w` to add word boundaries
smagick("Mark is number {'iw/mark'which ? x}.")
```

## Operations changing the length or the order

+ first: keeps only the first `n` elements. 

```{r}
smagick("First 3 mpg values: {3 first, C ? mtcars$mpg}.")

# you could have done the same with regular R in the expression...
smagick("First 3 mpg values: {C ? head(mtcars$mpg, 3)}.")

# ...but not in the middle of an operations chain
smagick("First 3 integer mpg values: {'!f/.'get, 3 first, C ? mtcars$mpg}.")
```

Negative numbers as argument remove the 
first `n` values. You can add a second argument in the form `'n1|n2'first` in which case the first `n1` and last
`n2` values are kept; `n1` and `n2` must be positive numbers.

```{r}
smagick("Letters in the middle: {13 first, 5 last, C ? letters}.")

smagick("First and last letters: {'3|3'first, C ? letters}.")

smagick("Last letters: {-21 first, C ? letters}.")
```

+ K: keeps only the first `n` elements; has more options than `first`. The syntax is `'n'K`, 
`'n|s'K`, `'n||s'K`. `n` provides the number of elements to keep. If `s` is provided and the number of 
elements are greater than `n`, then in `'n|s'` the string `s` is added at the end, and
if `'n||s'` the string s replaces the nth element.
The string `s` accepts specials values:
  + `:n:` or `:N:` which gives the total number of items in digits or letters (N)
  + `:rest:` or `:REST:` which gives the number of elements that have been truncated in digits or letters (REST)

```{r}
# basic use
smagick("First 3 letters: {'3'K, q, C ? letters}.")

# advanced use: using the extra argument
smagick("The letters are: {q, '3|:rest: others'K, C ? letters}.")
```

+ last: keeps only the last `n` elements. Negative numbers as argument remove the 
last `n` values.
```{r}
smagick("Last 3 mpg values: {3 last, C ? mtcars$mpg}.")

smagick("Removing the 3 last elements leads to {-3 last, C ! x{1:5}}.")
```

+ sort: sorts the vector in increasing order. Accepts an optional argument and the option "num". 
```{r}
x = c("sort", "me")
# basic use
smagick("{sort, c ? x}")
```
If an argument is provided, it must be a regex pattern that will be applied to
the vector using str_clean(). The sorting will be applied to the modified version of the vector
and the original vector will be ordered according to this sorting. 
```{r}
# first modifying the string before sorting
# here the regex first removes the first word, meaning that we sort on the last names
x = c("Jon Snow", "Khal Drogo")
smagick("{'.+ 'sort, C?x}")
```

The option "num" sorts over a numeric version 
(with silent conversion) of the vector and reorders the original vector accordingly. 
Values which could not be converted are last.
```{r}
x = "Mark is 34, Bianca is 55, Odette is 101, Julie is 21 and Frank is 5"
# sort on the "character string" number
smagick("{', | and 's, '\\D'sort, C ? x}")

# we extract the numbers, then convert to numeric, then sort
smagick("{', | and 's, '\\D'sort.num, C ? x}")
```
**Important note**: the sorting operation is applied before any character conversion.
If previous operations were applied, it is likely that numeric data were transformed to character.
```{r}
# note the difference
x = c(20, 100, 10)
# sorting on numeric
smagick("{sort, ' + 'c ? x}")
# sorting on character since 'n' operation transformed the vector to character
smagick("{n, sort, ' + 'c ? x}")
```

+ dsort: sorts the vector in decreasing order. It accepts an optional argument and 
the option "num". See the operation "sort" for a description of the argument and the option.
```{r}
smagick("5 = {dsort, ' + 'c ? 2:3}")
```

+ rev: reverses the vector.
```{r}
smagick("{rev, ''c ? 1:3}")
```

+ unik: makes the string vector unique. 
```{r}
smagick("Iris species: {unik, upper.first, C ? iris$Species}.")
```

+ each: repeats each element of the vector `n` times. Option "c" then collapses the full vector 
with the empty string as a separator. 
```{r}
# note: the slash special operations splits wrt to commas (see dedicated section)
smagick("{/x, y}{2 each ? 1:2}")

# illustrating collapsing
smagick("Large number: 1{5 each.c ! 0}")
```

+ times: repeats the vector sequence `n` times. Option "c" then collapses the full vector 
with the empty string as a separator. 
```{r}
smagick("What{6 times.c ! ?}")
```

+ rm: removes elements from the vector. Options: "empty", "blank", "noalpha", "noalnum", "all".
The *optional* argument represents the pattern used to detect strings to be deleted. 
```{r}
x = c("Luke", "Charles")
smagick("{'i/lu'rm ? x}")
```

By default it removes empty strings. 
Option "blank" removes strings containing only blank characters (spaces, tab, newline).
Option "noalpha" removes strings not containing letters. Option "noalnum" removes strings not 
containing alpha numeric characters. Option "all" removes all strings (useful in conditions, see 
the dedicated section). If an argument is provided, only the options "empty" and "blank" are available.

```{r}
x = c("I want to enter.", "Age?", "21.")
smagick("Nightclub conversation: {rm.noalpha, c ! - {x}}")
```

+ nuke: removes all elements, equivalent to `rm.all` but possibly more explicit. 
Useful in conditions, see the dedicated section.
```{r}
x = c(5, 7, 453, 647)
# here we use a condition: see the dedicated section for more information
smagick("Small numbers only: {if(.>20 ; nuke), C ? x}.")
```

+ insert: inserts a new element to the vector. Options: "right" and "both". Option "right" adds
the new element to the right. Option "both" inserts the new element on the two sides of the vector.

```{r}
smagick("{'3'insert.right, ' + 'c ? 1:2}")
```

## Formatting operations
 
+ lower: lower cases the full string.
+ upper: upper cases the full string. Options: "first" and "sentence".
Option "first" upper cases only the first character. Option "sentence"
upper cases the first letter after punctuation. 

```{r}
x = "hi. how are you? fine."
smagick("{upper.sentence ? x}")
```

+ title: applies a title case to the string. Options: "force" and "ignore".
Option "force" first puts everything to lowercase before applying the title case. 
Option "ignore" ignores a few small prepositions ("a", "the", "of", etc).

```{r}
x = "bryan is in the KITCHEN"

# default: respects upper cases
smagick("{title ? x}")

# force: force to title case
smagick("{title.force ? x}")

# ignore: ignores small prepositions
smagick("{title.force.ignore ? x}")
```

+ ws: normalizes whitespaces (WS). It trims the whitespaces on the edges and transforms any succession 
of whitespaces into a single one. Can also be used to further clean the string with its options. 
Options: "punct", "digit", "isolated". Option "punct" cleans the punctuation. Option "digit" cleans digits.
Option "isolated" cleans isolated letters. WS normalization always come after any of these options.
**Important note:** punctuation (or digits) are replaced with WS and **not** 
the empty string. This means that `smagick("ws.punct ! Meg's car")` will become "Meg s car".

```{r}
x = "   I    should? review 85 4 this text!!"
smagick("v0: {x}", 
        "v1: {ws ? x}",
        "v2: {ws.punct ? x}",
        "v3: {ws.punct.digit ? x}",
        "v4: {ws.punct.digit.isolated ? x}", sep = "\n")
```

+ trimws: trims the white spaces on both ends of the strings.

+ q, Q, bq: to add quotes to the strings. q: single quotes, Q: double quotes, bq: 
back quotes.
```{r}
x = c("Mark", "Pam")
smagick("Hello {q, C ? x}!")
```

+ format, Format: applies the base R's function [base::format()] to the string. 
By default, the values are left aligned, *even numbers* (differently from [base::format()]'s behavior).
The upper case command (`Format`) applies right alignment. Options: "0", "zero", "right", "center".
Options "0" or "zero" fills the blanks with 0s: useful to format numbers. Option "right" right aligns,
and "center" centers the strings.
```{r}
x = c(1, 12345) 
smagick("left:   {format, q, C ? x}", 
        "right:  {Format, q, C ? x}",
        "center: {format.center, q, C ? x}",
        "zero:   {format.0, q, C ? x}", sep = "\n")
```

+ %: applies base::sprintf() formatting. The syntax is 'arg'% with arg an sprintf formatting,
or directly the sprint formatting.
```{r}
smagick("pi = {%.3f ? pi}")
```

+ stopword: removes basic English stopwords (the snowball list is used). 
The stopwords are replaced with an empty space but the left and right WS are 
untouched. So WS normalization may be needed (see operation `ws`).
```{r}
x = c("He is tall", "He isn't young")
smagick("Is he {stop, ws, C ? x}?")
```

+ ascii: turns all letters into ASCII with transliteration. Failed translations are transformed 
into question marks. Options: "silent", "utf8". By default, if some conversion fails
a warning is prompted. Option "silent" disables the warning in case of failed conversion. The conversion 
is done with base::iconv(), option "utf8" indicates that the source endocing is UTF-8, can be useful 
in some cases.
```{r}
author = "Laurent Bergé"
smagick("This package has been developped by {ascii ? author}.")
```

+ n: formats integers by adding a comma to separate thousands. Options: "letter", "upper", "0", "zero".
The option "letter" writes the number in letters (large numbers keep their numeric format). The option
"upper" is like the option "letter" but uppercases the first letter. Options "0" or "zero" left pads
numeric vectors with 0s. 

```{r}
x = c(5, 12, 52123)
smagick("She owes {n, '$'paste, C ? x}.")

# option 0: all same width, no ',' for thousands
smagick("|---|\n{n.0, '\n'c ? x}")

# option upper
n = 5
smagick("{n.upper ? n} is my favourite number.")
```

+ N: same as `n` but automatically adds the option "letter".
```{r}
x = 5
smagick("He's {N ? x} years old.")
```

+ nth: when applied to a number, this operator writes them as a rank. Options: "letter", 
"upper", "compact".
```{r}
n = c(3, 7)
smagick("They finished {nth, enum ? n}!")
```
Option "letter" tries to write the numbers in letters, but note that it stops at 20. Option "upper"
is the same as "letter" but uppercases the first letter. Option "compact" aggregates
consecutive sequences in the form "start_n_th to end_n_th". 
```{r}
smagick("They arrived {nth.compact ? 5:20}.")
```

Nth: same as `nth`, but automatically adds the option "letter". 
```{r}
n = c(3, 7)
smagick("They finished {Nth, enum ? n}!")
```

+ ntimes: write numbers in the form `n` times. Options: "letter", "upper". Option 
"letter" writes the number in letters (up to 100). Option "upper" does the same as "letter" 
and uppercases the first letter. 
```{r}
smagick("They lost {C ! {ntimes ? c(1, 12)} against {/Real, Barcelona}}.")
```

+ Ntimes: same as `ntimes` but automatically adds the option "letter".
```{r}
x = 5
smagick("This paper was rejected {Ntimes ? x}...")
```

+ cfirst, clast: to select the first/last characters of each element. 
Negative numbers remove the first/last characters.
```{r}
smagick("{19 cfirst, 9 clast ! This is a very long sentence}")

smagick("delete 3 = {-3 cfirst ! delete 3}")
```

+ k: to keep only the first `n` characters (like `cfirst` but with more options). The
argument can be of the form `'n'k`, `'n|s'k` or `'n||s'k` with `n` a number and `s` a string.
`n` provides the number of characters to keep. Optionnaly, only for strings whose
length is greater than `n`, after truncation, the string `s` can be appended at the end.
The difference between `'n|s'` and `'n||s'` is that in the second case the strings
will always be of maximum size `n`, while in the first case they can be of length `n + nchar(s)`.
```{r}
x = "long sentence"
smagick("v0: {x}", 
        "v1: {4k ? x}", 
        "v2: {'4|..'k ? x}", 
        "v3: {'4||..'k ? x}", sep = "\n")
```

+ fill: fills the character strings up to a size. Options: "right", "center" and a free-form symbol.
Default is left-alignment of the strings. 
Option "right" right aligns and "center" centers the strings. You can pass a free-form symbol
as option, it will be used for the filling. By default if no argument is provided, the
maximum size of the character string is used. See help for str_fill() for more information.
```{r}
life = "full of sound and fury, Signifying nothing"
smagick("{'[ ,]+'s, upper.first, fill.center, q, '\n'c ? life}")

# fixing the length and filling with 0s
smagick("{5 fill.0.right, C ? c(1, 55)}")
```

+ paste: pastes a custom character string to all elements of the string. 
This operation has no default.
Options: "both", "right", "front", "back", "delete". By default, a string is pasted on the left.
Option "right" pastes on the right and "both" pastes on both sides. Option "front" only 
pastes on the first element while option "back" only pastes on the last element. Option "delete"
first replaces all elements with the empty string.
```{r}
smagick("6 = {'|'paste.both, ' + 'c ? -3:-1}")
```


## Other operations:

+ num: converts to numeric. Options: "warn", "soft", "rm", "clear". By default, the conversion
is performed silently and elements that fail to convert are turned into NA. 
Option "warns" displays a warning if the conversion to numeric fails. 
Option "soft" does not convert if the conversion of at least one element fails, leading to 
a character vector. 
Option "rm" converts and removes the elements that could not be converted. 
Option "clear" turns failed conversions into the empty string, and hence lead to a character vector.
```{r}
x = c(5, "six")
smagick("   origin: {C, q ? x}", 
        "      num: {num, C, q ? x}", 
        "   num.rm: {num.rm, C, q ? x}", 
        " num.soft: {num.soft, C, q ? x}", 
        "num.clear: {num.clear, C, q ? x}", sep = "\n")
```

+ enum: enumerates the elements. It creates a single string containing the comma 
separated list of elements.
If there are more than 7 elements, only the first 6 are shown and the number of
items left is written.
```{r}
smagick("enum ? 1:5")
```
You can add the following options:
  + q, Q, or bq: to quote the elements
  + or, nor: to finish with an 'or' (or 'nor') instead of an 'and'
  + i, I, a, A, 1: to enumerate with this prefix, like in: i) one, and ii) two
  + a number: to tell the number of items to display
```{r}
x = c("Marv", "Nancy")
smagick("The murderer must be {enum.or ? x}.")

x = c("orange", "milk", "rice")
smagick("Shopping list: {enum.i.q ? x}.")
```


+ len: gives the length of the vector. Options "letter", "upper", "format".
Option "letter" writes the length in words (up to 100). Option "upper" is the same 
as letter but uppercases the first letter. Option "format" add comma separation for thousands.
```{r}
smagick("Size = {len.format ? 1:5000}")
```

+ width: formats the string to fit a given width by cutting at word boundaries. 
Accepts arguments of the form `'n'` or `'n|s'`, with `n` a number and `s` a string. 
An argument of the form `'n|s'` will add `s` at the beginning of each line. Further,
by default a trailing white space is added to `s`; to remove this 
behavior, add an underscore at the end of it. 
The argument `n` is either 
an integer giving the target character width (minimum is 15), or it can be a fraction expressing the 
target size as a fraction of the current screen. Finally it can be an expression that 
uses the variable `.sw` which will capture the value of the current screen width.
```{r}
x = "this is a long sentence"
smagick("------ version 0 ------\n{x}", 
        "------ version 1 ------\n{15 width ? x}", 
        "------ version 2 ------\n{'15|#>'width ? x}",
        "------ version 3 ------\n{'15|#>_'width ? x}", sep = "\n")
```

+ dtime: displays a formatted time difference. Option "silent" does not report a warning if the
operation fails. It accepts either objects of class `POSIXt` or `difftime`.
```{r}
x = Sys.time()
Sys.sleep(0.15) 
smagick("Time: {dtime ? x}")
```

# Group-wise operations
#' 
#' In `smagick`, the splitting operation `s` (or `extract`) keeps a memory of the strings 
#' that were split. Use the tilde operator, of the form `~(op1, op2)`, to apply operations
#' group-wise, to each of the split strings.
#' 
#' Better with an example. `x = c("Oreste, Hermione", "Hermione, Pyrrhus", "Pyrrhus, Andromaque") ;`
#' `smagick("Troubles ahead: {S, ~(' loves 'c), C ? x}.")` leads to 
#' "Troubles ahead: Oreste loves Hermione, Hermione loves Pyrrhus and Pyrrhus loves Andromaque.".
#' 
#' Almost all operations can be applied group-wise (although only operations changing the order or 
#' the length of the strings really matter).
#' 
#' @section Conditional operations:
#' 
#' There are two operators to apply operations conditionally: `if` and `vif`, the latter
#' standing for *verbatim if*. 
#' 
#' The syntax of `if` is `if(cond ; ops_true ; ops_false)` with `cond` a
#' condition (i.e. logical operation) on the value being interpolated, `ops_true` a comma-separated
#' sequence of operations if the condition is `TRUE` and `ops_false` an *optional* a sequence of
#' operations if the condition is `FALSE`.
#' 
#' Ex.1: Let's take a sentence, delete words of less than 4 characters, and trim 
#' words of 7+ characters. 
#' x = "Songe Cephise a cette nuit cruelle qui fut pour tout un peuple une nuit eternelle"
#' `smagick("{' 's, if(.nchar<=4 ; nuke ; '7|..'k), c ? x}")`.
#' Let's break it down. First the sentence is split w.r.t. spaces, leading to a vector
#' of words. Then we use the special variable `.nchar` in `if`'s condition to refer 
#' to the number of characters of the current vector (the words). The words with 
#' less than 4 characters are nuked (i.e. removed), and the other words are
#' trimmed at 7 characters. Finally the modified vector of words is collapsed with 
#' the function `c`, leading to the result.
#' 
#' The condition `cond` accepts the following special values: `.` (the dot), `.nchar`, `.C`, `.len`, `.N`.
#' The dot, `.`, refers to the current vector. `.nchar` represent the number of characters 
#' of the current vector (equivalent to `nchar(.)`). `.C` is an alias to `.nchar`.
#' `.len` represent the length of the current vector (equivalent to `length(.)`). 
#' `.N` is an alias to `.len`.
#' 
#' If a condition leads to a result of length 1, then the operations are applied to 
#' the full string vector and not element-wise (as was the case in Ex.1). Contrary to element-wise conditions
#' for which operations modifying the length of the vectors are forbidden (apart from nuking),
#' such operations are fine in full-string conditions.
#' 
#' Ex.2: `x = smagick("x{1:10}")`; `smagick("y = {if(.N>4 ; 3 first, '...'insert.right), ' + 'c ? x}")`
#' leads to "y = x1 + x2 + x3 + ...". the same opration applied to `x = smagick("x{1:4}")`
#' leads to "y = x1 + x2 + x3 + x4".
#' 
#' For `vif`, the syntax is `vif(cond ; verb_true ; verb_false)` with `verb_true`
#' a verbatim value with which the vector will be replaced if the condition is `TRUE`. 
#' This is similar for `verb_false`. The condition works as in `if`.
#' 
#' Ex.3: `x = c(1, 25, 12, 6) ; smagick("Values: {vif(.<10 ; <10), C ? x}")` leads to 
#' "Values: <10, 25, 12 and <10". As we can see values lower than 10 are replaced
#' with "<10" while other values are not modified.
#' 
#' Ex.4: `x = smagick("x{1:10}")`; `smagick("y = {vif(.N>4 ; {/{x[1]}, ..., {last?x}}), ' + 'c ? x}")`
#' leads to "y = x1 + ... + x10".
#' Let's break it down. If the length of the vector is greater than 4 (here it's 10), then
#' the full string is replaced with "{/{x[1]}, ..., {last?x}}". Interpolation applies to
#' such string. Hence the slash operation (see the dedicated section) breaks the string w.r.t.
#' the commas, leading to the vector `c("{x[1]}", "...", "{last?x}")`. Since the 
#' string contain curly brackets, interpolation is applied again. This leads to 
#' the vector `c("x1", "...", "x10")`. Finally, this vector is collapsed with ' + ' leading
#' to the final string.
#' Note that there are many ways to get to the same result. Here is another example:
#' `smagick("y = {vif(.N>4 ; {x[1]} + ... + {last?x} ; {' + 'c ? x}) ? x}")`.
#' 
#' The `vif` condition allows the use of '.' to refer to the current value in 
#' `verb_true` and `verb_false`, as illustrated by the last example:
#' 
#' Ex.5: `smagick("{4 last, vif(. %% 2 ; x{.} ; y{rev?.}), C ? 1:11}")`
#' leads to "y10, x9, y8 and x11".
#' 
#' 
#' @section Special interpolation: The slash:
#' 
#' Interpolations starting with a slash are different from regular interpolations. 
#' Ex.1: `x = 3:4; smagick("{/one, two, {x}}")` leads to the vector `c("one", "two", "3", "4")`.
#' 
#' When a "/" is the first character of an interpolation:
#' - all characters until the closing bracket is taken as verbatim
#' - the verbatim string is split according to comma separation (formally they are split with `,[ \t\n]+`),
#' resulting into a vector
#' - if the vector contains any *box*, extra interpolations are resolved
#' 
#' In Ex.1 the string "one, two, {x}" is taken as verbatim and split w.r.t. commas, leading to c("one", "two", "{x}"). 
#' Since the last element contained an opening box, it is interpolated and inserted into the vector, leading
#' to the result.
#' 
#' By default, thanks to the argument `slash = TRUE`, you can apply the slash operator without
#' the need of an interpolation box (provided the slash appears as the first character), see the example below. 
#' 
#' Ex.2: `x = 3:4; smagick("/one, two, {x}")` also leads to the vector `c("one", "two", "3", "4")`.
#' 
#' @section Special interpolation: if-else:
#' 
#' Using an ampersand ("&") as the first character of an interpolation leads to an *if-else* operation.
#' Using two ampersands ("&&") leads to a slightly different operation described at the end of this section.
#' 
#' Ex.1: \code{x = 1:5; smagick("x is \{&length(x)<10 ; short ; \{`log10(length(x) - 1)`times, ''c ! very \}long\}")}
#' leads to "x is short". With `x = 1:50`, it leads to "x is long", and to "x is very very long"
#' if `x = 1:5000`.
#' 
#' The syntax is as follows: `{&cond ; verb_true ; verb_false}` with `cond` a
#' condition (i.e. logical operation) on the value being interpolated, `verb_true`
#' a verbatim value with which the vector will be replaced if the condition is `TRUE` and 
#' `verb_false` an *optional* verbatim value with which the vector will be replaced if the condition is `FALSE`. 
#' If not provided, `verb_false` is considered to be the empty string unless the operator is 
#' the double ampersand described at the end of this section.
#' 
#' If a condition leads to a result of length 1, the full string is replaced by the verbatim 
#' expression. Further, this expression will be interpolated if requested. This was the case
#' in Ex.1 where `varb_false` was interpolated.
#' 
#' If the condition's length is greater than 1, then each logical values equal to `TRUE` is replaced
#' by `verb_true`, and `FALSE` or `NA` values are replaced with `verb_false`. Note,
#' importantly, that **no interpolation is perfomed in that case**.
#' 
#' Ex.2: `x = 1:3 ; smagick("x is {&x == 2 ; two ; not two}")` leads to the vector 
#' `c("x is not two", "x is two", "x is not two")`.
#' 
#' Using the two ampersand operator ("&&") is like the simple ampersand version but the 
#' default for `verb_false` is the variable used in the condition itself. So the syntax is
#' {&&cond ; `verb_true`} and *it does not accept* `verb_false`.
#' 
#' Ex.3: `i = 3 ; smagick("i = {&&i == 3 ; three}")` leads to "i = three", and to "i = 5" if `i = 5`. 
#' 
#' 
#' @section Special interpolation: Pluralization:
#' 
#' There is advanced support for pluralization which greatly facilitates the writing of messages 
#' in natural language.
#' 
#' There are two ways to pluralize: over length or over value. To trigger a "pluralization" interpolation
#' use as first character:
#' - `$` to pluralize over the length of a variable (see Ex.2)
#' - `#` to pluralize over the value of a variable (see Ex.1)
#' 
#' Ex.1: `x = 5; smagick("I bought {N?x} book{#s}.")` leads to "I bought five books.". 
#' If `x = 1`, this leads to "I bought one book.".
#' 
#' The syntax is `{#plural_ops ? variable}` or `{#plural_ops}` where `plural_ops` are
#' specific pluralization operations which will be described below. 
#' The pluralization is perfomed *always* with respect to the value of a variable. 
#' You can either add the variable explicitly (`{#plural_ops ? variable}`) or refer
#' to it implicitly (`{#plural_ops}`). If implicit, then the algorithm will look at the 
#' previous variable that was interpolated and pluralize over it. This is exaclty what happens in
#' Ex.1 where `x` was interpolated in `{N?x}` and plural operation `s` in `{#s}` then applied to 
#' `x`. It was equivalent to have `{#s ? x}`. If a variable wasn't interpolated before, then
#' the next interpolated variable will be used (see Ex.2). If no variable is interpolated
#' at all, an error is thrown.
#' 
#' Ex.2: `x = c("J.", "M."); smagick("My BFF{$s, are} {C?x}!")` leads to "My BFFs are J. and M.!".
#' If "x = "S.", this leads to "My BFF is S.!".
#' 
#' Pluralizing accepts the following operations:
#' - s, es: adds an "s" (or "es") if it is plural (> 1), nothing otherwise. Accepts the option `0` or `zero` which 
#' treats a 0-length or a 0-value as plural.
#' - y or ies: adds an 'y' if singular and 'ies' if plural (>1). Accepts the option `0` or `zero` which 
#' treats a 0-length or a 0-value as plural.
#' - enum: enumerates the elements (see help for the regular operation `enum`)
#' - n, N, len, Len: add the number of elements ("len") or the value ("n") of the variable as a formatted number or 
#' in letters (upper case versions). Accepts the options `letter` (to write in letter) 
#' and `upper` (to uppercase the first letter).
#' - nth, ntimes: writes the value of the variable as an order (nth) or a frequence (ntimes). Accepts the option `letter`
#' to write the numbers in letters (uppercase version of the operator does the same).
#' - is, or any verb: conjugates the verb appropriately
#' 
#' You can chain operations, in that case a whitespace is automatically added between them.
#' 
#'  Ex.3: `x = c(7, 3, 18); smagick("The winning number{$s, is, enum ? sort(x)}.")`
#' leads to "The winning numbers are 3, 7 and 18.". With `x = 7` this leads to
#' "The winning number is 7.".
#' 
#' On top of the previous operations, there is a special operation allowing to add verbatim text depending on 
#' the situation. The syntax is as follows:
#' - `(s1;s2)`: adds verbatim 's1' if singular and 's2' if plural (>1)
#' - `(s1;s2;s3)`: adds verbatim 's1' if zero, 's2' if singular (=1) and 's3' if plural
#' - `(s1;;s3)`: adds verbatim 's1' if zero, 's3' if singular or plural (i.e. >=1)
#' 
#' These case-dependent verbatim values **are interpolated** (if appropriate). In these interpolations
#' you need not refer explicitly to the variable for pluralization interpolations.
#' 
#' Ex.4: `x = 3; smagick("{#(Sorry, nothing found.;;{#N.upper} match{#es, were} found.)?x}")` leads to 
#' "Three matches were found.". If "x = 1", this leads to "One match was found." and if "x = 0" this leads
#' to "Sorry, nothing found.".
#' 
#' @section Escaping and special cases:
#' 
#' The opening and closing brakets, `{}`, are special characters and cannot be used as regular text. 
#' To bypass their special meaning, you need to escape them with a double backslash.
#' 
#' Ex.1: `smagick("open = \\\\{, close = }")` leads to `"open = {, close = }"`.
#' Ex.2: `smagick("many {5 times.c ! \\\\}}")` leads to `many }}}}}`.
#' 
#' You only need to escape the special delimiters which the algorithm is currently looking for.
#' As you can see, you don't need to escape the closing bracket in Ex.1 since no box
#' was open. On the other hand, you need to escape it in Ex.2.
#' 
#' Alternatively, you can use the function `dsb()` to interpolate with `.[]` instead of `{}`.
#' You can also use the following hack:
#' 
#' Ex.3: smagick("I {'can {write} {{what}} I want'}") leads to `"I can {write} {{what}} I want"`.
#' 
#' Since `{expr}` evaluates `expr`, the stuff inside the *box*, you can pass a 
#' character string and it will stay untouched.
#' 
#' In the few operations expecting a semi-colon (if-else and pluralization), it can also be
#' escaped with a double backslash.
#' 
#' In interpolations, the exclamation mark (`!`) signals a verbatim expression. But what
#' if you use it to mean the logical operation *not* in an operation-free interpolation? 
#' In that case, you need a hack: use a question mark (`?`) first to indicate to the
#' algorithm that you want to evaluate the expression. 
#' 
#' Ex.4: `smagick("{!TRUE} is {?!TRUE}")` leads to "TRUE is FALSE". The first expression is
#' taken verbatim while the second is evaluated.


### examples

- example of counting the number of words in a text
- example of writing error messages: error handling
- parsing R code or any other text:
  - import données
  - virer commentaires
  - virer les lignes vides
  - concatener avec \n
  - supprimer les \n quand les virgules sont ouvertes
  - resplitter avec \n



```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
