% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/quickselect.R
\name{selvars}
\alias{selvars}
\title{Select, and create, variables from a data frame}
\usage{
selvars(
  .x,
  ...,
  .order = NULL,
  .in = NULL,
  .pattern = NULL,
  .frame = parent.frame(),
  .ignore.case = TRUE,
  .no_char_pattern = FALSE,
  .error_on_missing = FALSE
)
}
\arguments{
\item{.x}{Either a character vector or a data frame. In both cases, only a character
vector will be returned.}

\item{...}{Character scalar. A \strong{comma separated} list of patterns to select the variables. Ex: "var1, var2".
Let \code{var1} be an element of this pattern. By default, the variable exactly named \code{var1} is selected, and
if not present an error is raised. Use \code{^} as the first character to enable partial matching.
The value \code{"^petal"} selects all variables starting with \code{"petal"}. Use  \code{@} (resp. \verb{#})
as first character to enable regular expression (resp. fixed pattern) matching. For example \code{"@al$"} selects
all variables ending with \code{"al"}. Use \code{!} as first character to select all
variables \strong{not matching} the pattern. The value \code{"!#petal"} selects only the variables \strong{not} containing
\code{"petal"}: and this works retroactively! Hence \emph{all variables previously selected
that do not pass the negation are dropped}. To \emph{only include variables} through the negation, use the tag
\code{+} as first character. For example : \code{"petal.length, +!#petal"} selects the variable \code{petal.length}
and \emph{adds} all variables not containing the term "petal". Not using the "+" would have dropped the first variable.
To only apply a restriction when negating, use the tag \code{-} as first character.
Use a single pipe to sort all the previous variables: \code{"^petal | #length"} will select all the variables
starting with "petal" place the ones containing the term length first. To sort only the variables in a single
pattern, use the double pipe \code{||}: \code{"^petal, ^sepal | #length"} selects the variables starting with
"petal" and "sepal" and within the "sepal" variables places the ones containing the term length first.
After the pipes, use a comma separated list of values which work in the same way as the selection
previously described.
In case the argument \code{x} is a data set, you can use the special values \code{.num}, \code{.log}, \code{.lnum} (logical or numeric),
\code{.fact}, \code{.char}, \code{.fchar} (factor or character), \code{.date} to select variables base on their types.}

\item{.order}{Optional, default is \code{NULL}. A character scalar. A comma separated list of patterns to
order the variables. Works in the same way as the argument \code{pattern}. Partial reminder: you can use
special first characters. \code{!} to negate, \code{^} to partially match, \code{@} for regular expressions.
See more details in the help of the argument \code{...}.}
}
\value{
Returns a character vector.
}
\description{
multi-faceted pattern-based selection of variables
}
\details{
This function is tailored to select a list of variables from a data set. It also works for character strings.

For character strings, you may also be interested in \code{\link{str_get}}.
}
\examples{

x = rownames(mtcars)

# All variables starting with Maz
selvars(x, "^Maz")

# All Mercedes but not 450
selvars(x, "^Mer, !#450")

# All Mazda, and all cars that do not contain digits
selvars(x, "^Maz, &!@\\\\d")
# => note that without the `&` we would have dropped the Mazdas

# All cars containing digits, but not Mercedes, we put the Fiat first and Mazda last
selvars(x, "@\\\\d, !^Merc || ^Fiat, !^Maz")

#
# Using a data set as input, selecting via variables types
#

# selecting factor variables and variables starting with Sepal
selvars(iris, ".fact, ^Sepal")

}
