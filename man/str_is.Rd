% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/string_tools.R
\name{str_is}
\alias{str_is}
\title{Detects whether a pattern is in a character string}
\usage{
str_is(
  x,
  ...,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  or = FALSE,
  pattern = NULL
)
}
\arguments{
\item{x}{A character vector.}

\item{...}{Character scalars representing the patterns to be found. By default they are (perl) regular-expressions.
Use ' & ' or ' | ' to chain patterns and combine their result logically (ex: '[\link{:alpha:}] & \\d' gets strings
containing both letters and numbers). You can negate by adding a \code{!} first (ex: \code{"!sepal$"} will
return \code{TRUE} for strings that do not end with \code{"sepal"}).
Add flags with the syntax 'flag1, flag2/pattern'. Available flags are: 'fixed', 'ignore', 'word', 'verbatim'.
Ex: "ignore/sepal" would get "Sepal.Length" (wouldn't be the case w/t 'ignore').
Shortcut: use the first letters of the flags. Ex: "if/dt[" would get "DT\link{i = 5}" (flags 'ignore' + 'fixed').
The flag 'verbatim' does not parse logical operations. For 'word', see the documentation of this argument.}

\item{fixed}{Logical scalar, default is \code{FALSE}. Whether to trigger a fixed search instead of a
regular expression search (default).}

\item{ignore.case}{Logical scalar, default is \code{FALSE}. If \code{TRUE}, then case insensitive search is triggered.}

\item{word}{Logical scalar, default is \code{FALSE}. If \code{TRUE} then a) word boundaries are added to the pattern,
and b) patterns can be chained by separating them with a comma, they are combined with an OR logical operation.
Example: if \code{word = TRUE}, then pattern = "The, mountain" will select strings containing either the word
'The' or the word 'mountain'.}

\item{or}{Logical, default is \code{FALSE}. In the presence of two or more patterns,
whether to combine them with a logical "or" (the default is to combine them with a logical "and").}

\item{pattern}{(If provided, elements of \code{...} are ignored.) A character vector representing the
patterns to be found. By default a (perl) regular-expression search is triggered.
Use ' & ' or ' | ' to chain patterns and combine their result logically (ex: '[\link{:alpha:}] & \\d' gets strings
containing both letters and numbers). You can negate by adding a \code{!} first (ex: \code{"!sepal$"} will
return \code{TRUE} for strings that do not end with \code{"sepal"}).
Add flags with the syntax 'flag1, flag2/pattern'. Available flags are: 'fixed', 'ignore', 'word', 'verbatim'.
Ex: "ignore/sepal" would get "Sepal.Length" (wouldn't be the case w/t 'ignore').
Shortcut: use the first letters of the flags. Ex: "if/dt[" would get "DT\link{i = 5}" (flags 'ignore' + 'fixed').
The flag 'verbatim' does not parse logical operations. For 'word', see the documentation of this argument.}
}
\value{
It returns a logical vector of the same length as \code{x}.
}
\description{
Function that detects if one or more patterns are in a string. The patterns can be
chained, by default this is a regex search but special flags be triggered with a
specific syntax, supports negation.
}
\details{
Note that the parser of the patterns may lead to problems with some multibyte encodings. This is a limitation.
If such encodings should be in the pattern, then this function cannot be used, there is no workaround.
}
\examples{

x = dsb("/one, two, one... two, microphone, check")

# default is regular expression search
# => 3 character items
str_is(x, "^...$")

# to trigger fixed search use the flag 'fixed'
str_is(x, "fixed/...")
# you can just use the first letter
str_is(x, "f/...")

# to negate, use '!'
str_is(x, "!f/...")
# or directly in the pattern
str_is(x, "f/!...")

# you can combine several patterns with "&" or "|"
str_is(x, "one & c")
str_is(x, "one | c")

#
# word: adds word boundaries
#

# compare
str_is(x, "one")
# with
str_is(x, "w/one")

# words can be chained with commas (it is like an OR logical operation)
str_is(x, "w/one, two")
# compare with
str_is(x, "w/one & two")
# remember that you can still negate
str_is(x, "w/one & !two")#' 

# you can combine the flags
# compare
str_is(x, "w/ONE")
# with
str_is(x, "wi/ONE")

#
# str_which
#

# it works exactly the same way as str_is
# Which are the items containing an 'e' and an 'o'?
str_which(x, "e", "o")
# equivalently
str_which(x, "e & o")


}
