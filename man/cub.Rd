% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/string_operations.R
\name{print.smagick}
\alias{print.smagick}
\alias{cub}
\title{Simple and powerful string manipulation with the dot square bracket operator}
\usage{
\method{print}{smagick}(x, ...)

cub(
  ...,
  frame = parent.frame(),
  sep = "",
  vectorize = FALSE,
  slash = TRUE,
  collapse = NULL,
  use_DT = TRUE
)
}
\arguments{
\item{...}{Character scalars that will be collapsed with the argument \code{sep}. To interpolate, you can
use \code{"{x}"} within each character string to insert the value of \code{x} in the string.
You can add string operations in each \code{"{}"} instance with the syntax \code{"'arg'op ? x"}
(resp. \code{"'arg'op ! x"}) to apply the operation \code{'op'} with the argument \code{'arg'} to \code{x}
(resp. the verbatim of \code{x}). Otherwise, what to say? Ah, nesting is enabled, and since
there's over 50 operators, it's a bit complicated to sort you out in this small space.
But type \code{cub("--help")} to prompt an (almost) extensive help, or use the argument \code{help = "keyword"}
to obtain a selective help.}

\item{frame}{An environment used to evaluate the variables in \code{"{}"}. By default the variables are
evaluated using the environment from where the function is called.}

\item{sep}{Character scalar, default is the empty string \code{""}. It is used to collapse all
the elements in \code{...} before applying any operation.}

\item{vectorize}{Logical scalar, default is \code{FALSE}. If \code{TRUE}, Further, elements in \code{...} are
NOT collapsed together, but instead vectorised.}

\item{slash}{Logical, default is \code{TRUE}. If \code{TRUE}, then starting the string with a slash,
like in \code{cub("/one, two, three")} will split the character string after the slash breaking at
each comma followed by spaces or newlines. The previous example leads to the string vector
\code{c("one", "two", "three")}.

Any interpolation after the slash is vectorized. Example: \verb{a = 2:3 ; cub("/x1, x\{a\}, x4")} leads
to the vector \code{c("x1", "x2", "x3", "x4")}.}

\item{collapse}{Character scalar or \code{NULL} (default). If provided, the resulting
character vector will be collapsed into a character scalar using this value as a separator.

@details
There are over 50 basic string operations, it supports pluralization, string operations can be
nested (it may be the most powerful feature), operations can be applied conditionnally and
operators have sensible defaults.

You can also declare your own basic operations with \code{\link[=smagick_register]{smagick_register()}}.

See detailed help on the console with \code{cub("--help")} or use the argument \code{help} to which
you can pass keywords or regular expressions.}
}
\value{
It returns a character vector whose length depends on the elements and operations in \code{".[]"}.
}
\description{
Compactly performs many low level string operations. Advanced support for pluralization.
}
\section{Methods (by generic)}{
\itemize{
\item \code{print}: Simple print function for objects of class \code{smagick}
}}

\section{Interpolation and string operations}{
 principle:

To interpolate a variable, say \code{x}, simply use \code{{x}}. For example \verb{x = "world"; cub("hello \{x\}")} leads
to "hello world".

To any interpolation you can add operations. Taking the previous example, say we want to display
"hello W O R L D". This means upper casing all letters of the interpolated variable and adding a space between
each of them. Do you think we can do that? Of course yes: cub("hello {upper, ''s, c ? x}"). And that's it.

Now let's explain what happened. Within the \code{{}} \emph{box}, we first write a set of
operations, here "upper, ''s, c", then add "?" and finally write
the variable to interpolate, "x".  The operations (explained in more details
below) are \code{upper}, upper-casing all letters, ''s: splitting
with the empty string, 'c': concatenating with spaces the vector of string that was just split.
The question mark means that the expression coming after it is to be evaluated
(this is opposed to the exclamation mark presented next).

The syntax is always the same: {operations ? expression}, where the operations section
is a \emph{comma separated} list of operations.
These operations are of the form \verb{'arg'op}, with \code{arg} the argument to the operator
code \code{op}. These operations are performed sequantially from left to right.

Some operations, like \code{upper}, accept options. You attach options to an operation
with a dot followed by the option name. Formally: \code{op.option1.option2}, etc.
Example: \verb{x = "hi there. what's up? fine." ; cub("He said: \{upper.sentence, Q ? x\}")}.
Leads to: \verb{He said: "Hi there. What's up? Fine."}.

Both operators and options are partially matched. So \code{cub("He said: {up.s, Q ? x}")} would
also work.
}

\section{Verbatim interpolation and nesting}{
 principle:

Instead of interpolating a variable, say \code{x}, with \code{{x}}, you can use an exclamation
mark to trigger varbatim evaluation.
For example \code{cub("hello {!x}")} would lead to "hello x". It's a
bit disappointing, right? What's the point of doing that? Wait until the next two paragraphs.

Verbatim evaluation is a powerful way to apply operations to plain text. For example:
\code{cub("hello {upper, ''s, c ! world}")} leads to "hello W O R L D".

(A note in passing. The spaces surrounding the exclamation mark are non necessary,
but when one space is present on both sides of the \code{!}, then the verbatim
expression only begins after it. Ex: "{upper! hi}" leads to " HI" while "{upper ! hi}"
leads to "HI" and "{upper !  hi}" leads to " HI".)

The second advantage of verbatim evaluations is \emph{nesting}. Anything in a verbatim
expression is evaluated with the function \code{cub}.
This means that any \emph{box} will be evaluated as previously described. Let's
give an example. You want to write the expression of a polynomial of order n: a + bx + cx^2 + etc.
You can do that with nesting. Assume we have \code{n = 2}.

Then \code{cub("poly({n}): {' + 'c ! {letters[1 + 0:n]}x^{0:n}}")} leads to
"poly(2): ax^0 + bx^1 + cx^2".

How does it work? The verbatim expression (the one following the exclamation mark),
here "{letters\link{1 + 0:n}}x^{0:n}", is evaluated with \code{cub}.
\code{cub("{letters[1 + 0:n]}x^{0:n}")} leads to the vector c("ax^0", "bx^1", "cx^2").

The operation \verb{' + 'c} then concatenates (or collapses) that vector with ' + '.
This value is then appended to the previous string.

We could refine by adding a cleaning operation in which we replace "x^0" and "^1"
by the empty string. Let's do it:

\code{cub("poly({n}): {' + 'c, 'x\\\\^0|\\\\^1'r ! {letters[1 + 0:n]}x^{0:n}}")} leads to
"poly(2): a + bx + cx^2", what we wanted.

You can try to write a function to express the polynomial as before: although it is
a simple task, my guess is that it will require more typing.
}

\section{General operations syntax}{


As seen in the previous sections, within a \emph{box} (i.e. \code{"{}"}), multiple operations
can be performed.
We can do so by stacking the operations codes and in a comma separated enumeration.
Operations can have arguments, and operations can also have options. The general
syntax, with argument and options, is:

\verb{\{'arg1'op1.optionA.optionB, arg2 op2.optionC, }arg3\verb{op3, 51op4 ? x\}}

The argument can appear in four forms: a) inside single or double quotes just
before the operation name (\code{arg1} above),
b) verbatim, separated with a space, just before the operation name (\code{arg2} above),
c) inside bactick quotes the argument is evaluated from the environment (\code{arg3} above),
or d) when the argument is an integer it can be juxtaposed to the opeation name (like in \code{op4} above).

The options are always dot separated and attached to the operation name, they are
specific to each operation.

Both the operation name and the option names are partially matched.
}

\section{Basic string operations}{


This section describes some of the most common string operations: extracting, replacing, collapsing, splitting, etc.
These functions accept generic flags ("ignore", "fixed", "word") in their patterns (syntax: "flags/pattern").
Please see the dedicated section for more information on flags.
\itemize{
\item s, S: splits the string according to a pattern. The two operations have different defaults: \code{' '}
for \code{s} and ',[ \t\n}*' for \code{S} (i.e. comma separation).
Ex.1: \code{cub("S ! romeo, juliet")} leads to the vector c("romeo", "juliet").
Ex.2: \code{cub("{'f/+'s, '-'c ! 5 + 2} = 3")} leads to "5 - 2 = 3" (note the flag "fixed" in \code{s}'s pattern).
\item c, C: to concatenate multiple strings into a single one. The two operations are
identical, only their default change. c: default is ' ', C: default is ', | and '.
The syntax of the argument is 's1' or 's1|s2'. s1 is the string used to concatenate
(think \code{paste(x, collapse = s1)}). In arguments of the form \code{'s1|s2'}, \code{s2} will be used to concatenate the last two elements.
Ex.1: \verb{x = 1:4; cub("Et \{' et 'c ? x\}!")} leads to "Et 1 et 2 et 3 et 4!".
Ex.2: \code{cub("Choose: {', | or 'c ? 2:4}?")} leads to "Choose: 2, 3 or 4?".
\item x, X: extracts patterns from a string. Both have the same default: '[\link{:alnum:}]+'.
\code{x} extracts the first match while \code{X} extracts \strong{all} the matches.
Ex.1: \verb{x = c("6 feet under", "mahogany") ; cub("\{'\\\\w\{3\}'x ? x\}")} leads to the vector c("fee", "mah").
Ex2.: \verb{x = c("6 feet under", "mahogany") ; cub("\{'\\\\w\{3\}'X ? x\}")} leads to the
vector c("fee", "und", "mah", "oga").
\item extract: extracts multiple patterns from a string, this is an alias to the operation \code{X} described above.
Use the option "first" to extract only the first match for each string (behavior becomes like \code{x}).
Ex: \verb{x = c("margo: 32, 1m75", "luke doe: 27, 1m71") ; cub("\{'^\\\\w+'extract ? x\} is \{'\\\\d+'extract.first ? x\}")}
leads to c("margo is 32", "luke is 27").
\item r, R: replacement within a string. The two operations are identical and have no default.
The syntax is \code{'old'} or \code{'old => new'} with \code{'old'} the pattern to find and \code{new} the replacement. If \code{new} is missing, it is
considered the empty string. This operation also accepts the flag "total" which instruct to
replace the fulll string in case the pattern is found.
Ex.1: \code{cub("{'e'r ! Where is the letter e?}")} leads to "Whr is th lttr ?".
Ex.2: \code{cub("{'(?<!\\\\b)e => a'R ! Where is the letter e?}")} leads to "Whara is tha lattar e?".
Ex.3: \code{cub("{'t/e => here'r ! Where is the letter e?}")} leads to "here".
\item get: restricts the string only to values respecting a pattern. This operation has no default.
It uses the same syntax as \code{\link[=str_get]{str_get()}} so that you can include logical operations with ' & ' and ' | '.
Example: \verb{x = row.names(mtcars) ; cub("Mercedes models: \{'Merc & [[:alpha:]]$'get, '^.+ 'r, C ? x\}")}
leads to "Mercedes models: 240D, 280C, 450SE, 450SL and 450SLC".
\item is: detects if a pattern is present in a string, returns a logical vector. This operation has no default.
Mostly useful as the final operation in a \code{\link[=str_op]{str_op()}} call.
Example: \verb{x = c("Mark", "Lucas") ; cub("Mark? \{'i/mark'is, C ? x\}")} leads to "Mark? TRUE and FALSE".
\item which: returns the index of string containing a specified pattern. With no default, can be applied
to a logical vector directly. Mostly useful as the final operation in a \code{\link[=str_op]{str_op()}} call.
Ex.1: \verb{x = c("Mark", "Lucas") ; cub("Mark is number \{'i/mark'which ? x\}.")} leads to
"Mark is number 1.".
}
}

\section{Operations changing the length or order of the vector}{

\itemize{
\item first: keeps only the first \code{n} elements. Example: \code{cub("First 3 numbers: {3 first, C ? mtcars$mpg}.")}
leads to "First 3 numbers: 21, 21 and 22.8.". Negative numbers as argument remove the
first \code{n} values.
\item K, Ko, KO: keeps only the first \code{n} elements; has more options than \code{first}. The syntax is 'n'K,
'n|s'K, 'n||s'K. The values Ko and KO only accept the two first syntax (with \code{n} only).
\code{n} provides the number of elements to keep. If \code{s} is provided and the number of
elements are greater than \code{n}, then in 'n|s' the string \code{s} is added at the end, and
if 'n||s' the string s replaces the nth element.
The string \code{s} accepts specials values:
\itemize{
\item \verb{:n:} or \verb{:N:} which gives the total number of items in digits or letters (N)
\item \verb{:rest:} or \verb{:REST:} which gives the number of elements that have been truncated in digits or letters (REST)
Ex: \code{cub("'3|:rest: others'K ? 1:200")} leads to the vector \code{c("1", "2", "3", "197 others")}.
\item The operator 'n'Ko is like \verb{'n||:rest: others'K} and 'n'KO is like \verb{'n||:REST: others'K}.
}
\item last: keeps only the last \code{n} elements. Example: \code{cub("Last 3 numbers: {3 last, C ? mtcars$mpg}.")}
leads to "Last 3 numbers: 19.7, 15 and 21.4.". Negative numbers as argument remove the
last \code{n} values.
\item sort: sorts the vector in increasing order. Example: \verb{x = c("sort", "me") ; cub("\{sort, c ? x\}")}
leads to "me sort". \strong{Important note}: the sorting operation is applied before any character conversion.
If previous operations were applied, it is likely that numeric data were transformed to character.
Note the difference: \verb{x = c(20, 100, 10); cub("\{sort, ' + 'c ? x\}")} leads to "10 + 20 + 100"
while \code{cub("{n, sort, ' + 'c ? x}")} leads to "10 + 100 + 20" because the operation "n"
first transformed the numeric vector into character.
\item dsort: sorts the vector in decreasing order. Example: \code{cub("5 = {dsort, ' + 'c ? 2:3}")}
leads to "5 = 3 + 2". Same note as for the operation "sort".
\item rev: reverses the vector. Example: \code{cub("{rev, ''c ? 1:3}")} leads to "321".
\item unik: makes the string vector unique. Example: \code{cub("Iris species: {unik, C ? iris$Species}.")}
leads to "Iris species: setosa, versicolor and virginica.".
\item each: repeats each element of the vector \code{n} times. Option "c" then collapses the full vector
with the empty string as a separator. Ex.1: \code{cub("{/x, y}{2 each ? 1:2}")} leads to the
vector \code{c("x1", "y1", "x2", "y2")}. Ex.2: cub("Large number: 1{5 each.c ! 0}") leads to
"Large number: 100000".
\item times: repeats the vector sequence \code{n} times. Option "c" then collapses the full vector
with the empty string as a separator. Example: \code{cub("What{6 times.c ! ?}")} leads to "What??????".
\item rm: removes elements from the vector. Options: "empty", "blank", "noalpha", "noalnum", "all".
The \emph{optional} argument represents the pattern used to detect strings to be deleted.
Ex.1: x = c("Luke", "Charles"); cub("{'i/lu'rm ? x}") leads to "charles". By default it removes
empty strings. Option "blank" removes strings containing only blank characters (spaces, tab, newline).
Option "noalpha" removes strings not containing letters. Option "noalnum" removes strings not
containing alpha numeric characters. Option "all" removes all strings (useful in conditions, see
the dedicated section). If an argument is provided, only the options "empty" and "blank" are available.
Ex.2: \verb{x = c("I want to enter.", "Age?", "21"); cub("Nightclub conversation: \{rm.noalpha, c ! - \{x\}\}")}
leads to "Nightclub conversation: - I want to enter. - Age?"
\item nuke: removes all elements, equivalent to \code{rm.all} but possibly more explicit (not sure).
Useful in conditions, see the dedicated section.
Example: \verb{x = c(5, 7, 453, 647); cub("Small numbers only: \{if(.>20 ; nuke), C ? x\}")} leads
to "Small numbers only: 5 and 7";
\item append: appends a new element to the vector. Options: "right" and "both". Option "right" adds
the new element to the right. Option "both" appends the new element on the two sides of the vector.
Example: \code{cub("{'3'append.right, ' + 'c ? 1:2}")} leads to "1 + 2 + 3".
}
}

\section{Formatting operations}{

\itemize{
\item lower: lower cases the full string.
\item upper: upper cases the full string. Options: "first" and "sentence".
Option "first" upper cases only the first character. Option "sentence"
upper cases the first letter after punctuation.
Ex: \verb{x = "hi. how are you? fine." ; cub("\{upper.sentence ? x\}")} leads
to "Hi. How are you? Fine.".
\item title: applies a title case to the string. Options: "force" and "ignore".
Option "force" first puts everything to lowercase before applying the title case.
Option "ignore" ignores a few small prepositions ("a", "the", "of", etc).
Ex: \verb{x = "bryan is in the KITCHEN" ; cub("\{title.force.ignore ? x\}")} leads to "Bryan Is in the Kitchen".
\item ws: normalizes whitespaces (WS). It trims the whitespaces on the edges and transforms any succession
of whitespaces into a single one. Can also be used to further clean the string with its options.
Options: "punct", "digit", "isolated". Option "punct" cleans the punctuation. Option "digit" cleans digits.
Option "isolated" cleans isolated letters. WS normalization always come after any of these options.
\strong{Important note:} punctuation (or digits) are replaced with WS and \strong{not}
the empty string. This means that \code{cub("ws.punct ! Meg's car")} will become "Meg s car".
\item trimws: trims the white spaces on both ends of the strings.
\item q, Q, bq: to add quotes to the strings. q: single quotes, Q: double quotes, bq:
back quotes. \verb{x = c("Mark", "Pam"); cub("Hello \{q, C ? x\}!")} leads to "Hello 'Mark' and 'Pam'!".
\item format, Format: applies the base R's function \code{\link[base:format]{base::format()}} to the string.
By default, the values are left aligned, \emph{even numbers} (differently from \code{\link[base:format]{base::format()}}'s behavior).
The upper case command (\code{Format}) applies right alignment. Options: "0", "zero", "right", "centre", "center".
Options "0" or "zero" fills the blanks with 0s: useful to format numbers. Option "right" right aligns,
and "centre" or "centre" centers the strings.
Ex: \verb{x = c(1, 12345); cub("left: \{format.0, q, C ? x\}, right: \{Format, q, C ? x\}")}
leads to "left: '000001' and '12,345', right: '     1' and '12,345'".
\item \%: applies \code{\link[base:sprintf]{base::sprintf()}} formatting. The syntax is 'arg'\% with arg an sprintf formatting,
or directly the sprint formatting, e.g. \verb{\% 5s}. Example: \code{cub("pi = {\%.3f ? pi}")} leads
to "pi = 3.142".
\item stop: removes basic English stopwords (the snowball list is used).
The stopwords are replaced with an empty space but the left and right WS are
untouched. So WS normalization may be needed (see operation \code{ws}).
\verb{x = c("He is tall", "He isn't young"); cub("Is he \{stop, ws, C ? x\}?")} leads to "Is he tall and young?".
\item ascii: turns all letters into ASCII with transliteration. Non ASCII elements
are transformed into question marks. Options: "silent", "utf8". By default, if some conversion fails
a warning is prompted. Option "silent" disables the warning in case of failed conversion. The conversion
is done with \code{\link[base:iconv]{base::iconv()}}, option "utf8" indicates that the source endocing is UTF-8, can be useful
in some cases.
\item n: formats integers by adding a comma to separate thousands. Options: "letter", "upper", "0", "zero".
The option "letter" writes the number in letters (large numbers keep their numeric format). The option
"upper" is like the option "letter" but uppercases the first letter. Options "0" or "zero" left pads
numeric vectors with 0s. Ex.1: \verb{x = 5; cub("He's \{N ? x\} year old.")} leads to "He's five year old.".
Ex.2: \verb{x = c(5, 12, 52123); cub("She owes \{n.0, '$'paste, C ? x\}.")} leads to
"She owes $5, $12 and $52,123.".
\item N: same as \code{n} but automatically adds the option "letter".
\item nth: when applied to a number, these operators write them as a rank. Options: "letter",
"upper", "compact".
Ex.1: \verb{n = c(3, 7); cub("They finished \{nth, enum ? n\}!")} leads to "They finished 3rd and 7th!".
Option "letter" tries to write the numbers in letters, but note that it stops at 20. Option "upper"
is the same as "letter" but uppercases the first letter. Option "compact" aggregates
consecutive sequences in the form "start_n_th to end_n_th".
Ex.2: cub("They arrived {nth.compact ? 5:20}.") leads to "They arrived 5th to 20th.".
Nth: same as \code{nth}, but automatically adds the option "letter". Example:
\verb{n = c(3, 7); cub("They finished \{Nth, enum ? n\}!")} leads to "They finished third and seventh!".
\item ntimes: write numbers in the form \code{n} times. Options: "letter", "upper". Option
"letter" writes the number in letters (up to 100). Option "upper" does the same as "letter"
and uppercases the first letter. Example: \code{cub("They lost {C ! {ntimes ? c(1, 12)} against {/Real, Barcelona}}.")}
leads to "They lost once against Real and 12 times against Barcelona.".
\item Ntimes: same as \code{ntimes} but automatically adds the option "letter".
Example: \verb{x = 5; cub("This paper was rejected \{Ntimes ? x\}...")} leads to
"This paper was rejected five times...".
\item cfirst, clast: to select the first/last characters of each element.
Ex: cub("{19 cfirst, 9 clast ! This is a very long sentence}") leads to "very long".
Negative numbers remove the first/last characters.
\item k: to keep only the first n characters (like cfirst but with more options). The
syntax is \code{nk}, \verb{'n'k}, \verb{'n|s'k} or \verb{'n||s'k} with \code{n} a number and \code{s} a string.
\code{n} provides the number of characters to keep. Optionnaly, only for strings whose
length is greater than \code{n}, after truncation, the string \code{s} can be appended at the end.
The difference between 'n|s' and 'n||s' is that in the second case the strings
will always be of maximum size \code{n}, while in the first case they can be of length \code{n + nchar(s)}.
Ex: \code{cub("{4k ! long sentence}")} leads to "long",  \code{cub("{'4|..'k ! long sentence}") }
leads to "long..", \code{cub("{'4||..'k ! long sentence}")} leads to "lo..".
\item fill: fills the character strings up to a size. Options: "right", "center" and a free-form symbol.
Option "right" right aligns and "center" centers the strings. You can pass a free-form symbol
as option, it will be used for the filling. By default if no argument is provided, the
maximum size of the character string is used. See help for \code{\link[=str_fill]{str_fill()}} for more information.
Ex.1: \code{cub("Numbers: {'5'fill.0.right, C ? c(1, 55)}")} leads to "Numbers: 00001 and 00055".
\item paste: pastes some character to all elements of the string. This operation has no default.
Options: "both", "right", "front", "back", "delete". By default, a string is pasted on the left.
Option "right" pastes on the right and "both" pastes on both sides. Option "front" only
pastes on the first element while option "back" only pastes on the last element. Option "delete"
first replaces all elements with the empty string.
Example: \code{cub("6 = {'|'paste.both, ' + 'c ? -3:-1}")} leads to "6 = |-3| + |-2| + |-1|".
}
}

\section{Other operations}{

\itemize{
\item num: converts to numeric. Options: "warn", "soft", "rm", "clean". By default, the conversion
is performed silently and elements that failed to convert are turned into NA.
Option "warns" displays a warning if the conversion to numeric fails.
Option "soft" does not convert if the conversion of at least one element fails.
Option "rm" converts and removes the elements that could not be converted.
Option "clean" turns failed conversions into the empty string, and hence lead to a character vector.
Example: \verb{x = c(5, "six"); cub("Compare \{num, C, q ? x\} with \{num.rm, C, q ? x\}.")} leads to
"Compare '5 and NA' with '5'.", and \code{cub("Compare {num.soft, C, q ? x} with {num.clean, C, q ? x}.")}
leads to "Compare '5 and six' with '5 and '.".
\item enum: enumerates the elements. It creates a single string containing the comma
separated list of elements.
If there are more than 7 elements, only the first 6 are shown and the number of
items left is written.
For example \code{cub("enum ? 1:5")} leads to "1, 2, 3, 4, and 5".
You can add the following options by appending the letter to enum after a dot:
\itemize{
\item q, Q, or bq: to quote the elements
\item or, nor: to finish with an 'or' (or 'nor') instead of an 'and'
\item i, I, a, A, 1: to enumerate with this prefix, like in: i) one, and ii) two
\item a number: to tell the number of items to display
Ex.1: \verb{x = c("Marv", "Nancy"); cub("The main characters are \{enum ? x\}.")} leads to
"The main characters are Marv and Nancy.".
Ex.2: \verb{x = c("orange", "milk", "rice"); cub("Shopping list: \{enum.i.q ? x\}.")} leads to
"Shopping list: i) 'orange', ii) 'milk', and iii) 'rice'."
}
\item len: gives the length of the vector. Options "letter", "upper", "format".
Option "letter" writes the length in words (up to 100). Option "upper" is the same
as letter but uppercases the first letter. Option "format" add comma separation for thousands.
Example: \code{cub("Size = {len.format ? 1:5000}")} leads to "Size = 5,000".
\item swidth: formats the string to fit a given width by cutting at word boundaries. You can add
a free-form option which will appear at the beginning of the string. If you provide a free-form option
equal to a leading string, by default a trailing white space is added; to remove this
behavior, add an underscore at the end of the option.
The argument is either
an integer giving the target character width (minimum is 15), or it can be a fraction expressing the
target size as a fraction of the current screen.
Ex.1: \code{cub("{15 swidth ! this is a long sentence}")} leads to "this is a long\\nsentence".
Ex.2: \code{cub("{15 swidth.#> ! this is a long sentence}")} leads to "#> this is a long\\n#> sentence".
\item dtime: displays a formatted time difference. Option "silent" does not report an warning if the
operation fails. It accepts either objects of class \code{POSIXt} or \code{difftime}.
Example: \verb{x = Sys.time() ; Sys.sleep(0.5) ; cub("Time: \{dtime ? x\}")} leads to something
like "Time: 514ms".
}
}

\section{Group-wise operations}{


In \code{smagick}, the splitting operation \code{s} (or \code{S}) keeps a memory of the strings
that were split. Use the tilde operator, of the form \verb{~(op1, op2)}, to apply operations
group-wise, to each of the split strings.

Better with an example. \code{x = c("Oreste, Hermione", "Hermione, Pyrrhus", "Pyrrhus, Andromaque") ;}
\code{cub("Troubles ahead: {S, ~(' loves 'c), C ? x}.")} leads to
"Troubles ahead: Oreste loves Hermione, Hermione loves Pyrrhus and Pyrrhus loves Andromaque.".

Almost all operations can be applied group-wise (although only operations changing the order or
the length of the strings really matter).
}

\section{Conditionnal operations}{


There are two operators to apply operations conditionnally: \code{if} and \code{vif}, the latter
standing for \emph{verbatim if}.

The syntax of \code{if} is \verb{if(cond ; ops_true ; ops_false)} with \code{cond} a
condition (i.e. logical operation) on the value being interpolated, \code{ops_true} a comma-separated
sequence of operations if the condition is \code{TRUE} and \code{ops_false} an \emph{optional} a sequence of
operations if the condition is \code{FALSE}.

Ex.1: Let's take a sentence, delete words of less than 4 characters, and trim
words of 7+ characters.
x = "Songe Cephise a cette nuit cruelle qui fut pour tout un peuple une nuit eternelle"
\code{cub("{' 's, if(.nchar<=4 ; nuke ; '7|..'k), c ? x}")}.
Let's break it down. First the sentence is split w.r.t. spaces, leading to a vector
of words. Then we use the special variable \code{.nchar} in \code{if}'s condition to refer
to the number of characters of the current vector (the words). The words with
less than 4 characters are nuked (i.e. removed), and the other words are
trimmed at 7 characters. Finally the modified vector of words is collapsed with
the function \code{c}, leading to the result.

The condition \code{cond} accepts the following special values: \code{.} (the dot), \code{.nchar}, \code{.C}, \code{.len}, \code{.N}.
The dot, \code{.}, refers to the current vector. \code{.nchar} represent the number of characters
of the current vector (equivalent to \code{nchar(.)}). \code{.C} is an alias to \code{.nchar}.
\code{.len} represent the length of the current vector (equivalent to \code{length(.)}).
\code{.N} is an alias to \code{.len}.

If a condition leads to a result of length 1, then the operations are applied to
the full string vector and not element-wise (as was the case in Ex.1). Contrary to element-wise conditions
for which operations modifying the length of the vectors are forbidden (apart from nuking),
such operations are fine in full-string conditions.

Ex.2: \code{x = cub("x{1:10}")}; \code{cub("y = {if(.N>4 ; 3 first, '...'append.right), ' + 'c ? x}")}
leads to "y = x1 + x2 + x3 + ...". the same opration applied to \code{x = cub("x{1:4}")}
leads to "y = x1 + x2 + x3 + x4".

For \code{vif}, the syntax is \verb{vif(cond ; verb_true ; verb_false)} with \code{verb_true}
a verbatim value with which the vector will be replaced if the condition is \code{TRUE}.
This is similar for \code{verb_false}. The condition works as in \code{if}.

Ex.3: \verb{x = c(1, 25, 12, 6) ; cub("Values: \{vif(.<10 ; <10), C ? x\}")} leads to
"Values: <10, 25, 12 and <10". As we can see values lower than 10 are replaced
with "<10" while other values are not modified.

Ex.4: \code{x = cub("x{1:10}")}; \code{cub("y = {vif(.N>4 ; {/{x[1]}, ..., {last?x}}), ' + 'c ? x}")}
leads to "y = x1 + ... + x10".
Let's break it down. If the length of the vector is greater than 4 (here it's 10), then
the full string is replaced with "{/{x\link{1}}, ..., {last?x}}". Interpolation applies to
such string. Hence the slash operation (see the dedicated section) breaks the string w.r.t.
the commas, leading to the vector \code{c("{x[1]}", "...", "{last?x}")}. Since the
string contain curly brackets, interpolation is applied again. This leads to
the vector \code{c("x1", "...", "x10")}. Finally, this vector is collapsed with ' + ' leading
to the final string.
Note that there are many ways to get to the same result. Here is another example:
\code{cub("y = {vif(.N>4 ; {x[1]} + ... + {last?x} ; {' + 'c ? x}) ? x}")}.
}

\section{Special interpolation}{
 The slash:

Interpolations starting with a slash are different from regular interpolations.
Ex.1: \verb{x = 3:4; cub("\{/one, two, \{x\}\}")} leads to the vector \code{c("one", "two", "3", "4")}.

When a "/" is the first character of an interpolation:
\itemize{
\item all characters until the closing bracket is taken as verbatim
\item the verbatim string is split according to comma separation (formally they are split with \verb{,[ \\t\\n]+}),
resulting into a vector
\item if the vector contains any \emph{box}, extra interpolations are resolved
}

In Ex.1 the string "one, two, {x}" is taken as verbatim and split w.r.t. commas, leading to c("one", "two", "{x}").
Since the last element contained an opening box, it is interpolated and inserted into the vector, leading
to the result.

By default, thanks to the argument \code{slash = TRUE}, you can apply the slash operator without
the need of an interpolation box (provided the slash appears as the first character), see the example below.

Ex.2: \verb{x = 3:4; cub("/one, two, \{x\}")} also leads to the vector \code{c("one", "two", "3", "4")}.

 if-else:

Using an ampersand ("&") as the first character of an interpolation leads to an \emph{if-else} operation.
Using two ampersands ("&&") leads to another operation described at the end of this section.

Ex.1: \verb{x = 1:50; cub("x is \{&length(x)<10 ; short ; \{\\}log10(length(x) - 1)\\verb{times, ''c ! very \}long\}")}

\code{x = 1:50; cub("x is \{&length(x)<10 ; short ; \{`log10(length(x) - 1)`times, ''c ! very \}long\}")}

The syntax is as follows: \verb{\{&cond ; verb_true ; verb_false\}} with \code{cond} a
condition (i.e. logical operation) on the value being interpolated, \code{verb_true}
a verbatim value with which the vector will be replaced if the condition is \code{TRUE} and
\code{verb_false} an \emph{optional} verbatim value with which the vector will be replaced if the condition is \code{FALSE}.

If a condition leads to a result of length 1,

 Pluralization:

"  To trigger pluralization use a dollar sign right at the beginning of the operators.",

TO WRITE

As just seen, within a box you can add a set of operations to be performed. The thing is,
by default the main string is considered to be, when appropriate, within a box.
This means that you can perform operations right from the start: \code{cub("U, ''s, c ! yes!")} leads to "Y E S !".

This is in fact equivalent to \code{cub("{U, ''s, c ! yes!}")}. Note that this behavior
is triggered only when appropriate.
However in some instances it may interfere with what the user really wants. You can
disable this feature with \code{nest = FALSE}.
}

\section{Generic pattern flags}{


All \code{stringmagick} functions support generic flags in regular-expression patterns.
The flags are useful to quickly give extra instructions, similarly to \emph{usual}
\href{https://javascript.info/regexp-introduction}{regular expression flags}.

Here the syntax is "flag1, flag2/pattern". That is: flags are a comma separated list of flag-names
separated from the pattern with a slash (\code{/}). Example: \code{str_which(c("hello...", "world"), "fixed/.")} returns \code{1}.
Here the flag "fixed" removes the regular expression meaning of "." which would have otherwise meant \emph{"any character"}.
The no-flag verion \code{str_which(c("hello...", "world"), ".")} returns \code{1:2}.

Alternatively, and this is recommended, you can collate the initials of the flags instead of using a
comma separated list. For example: "if/dt[" will apply the flags "ignore" and "fixed" to the pattern "dt[".

The three flags always available are: "ignore", "fixed" and "word".
\itemize{
\item "ignore" instructs to ignore the case. Technically, it adds the perl-flag "(?i)" at the beginning of the pattern.
\item "fixed" removes the regular expression interpretation, so that the characters ".", "$", "^", "["
(among others) lose their special meaning and are treated for what they are: simple characters.
\item "word" adds word boundaries (\code{"\\\\b"} in regex language) to the pattern. Further, the comma (\code{","})
becomes a word separator. Technically, "word/one, two" is treated as "\\b(one|two)\\b". Example:
\code{str_clean("Am I ambushed?", "wi/am")} leads to " I ambushed?" thanks to the flags "ignore" and "word".
}
}

\examples{

#
# BASIC USAGE ####
#

x = c("Romeo", "Juliet")

# .[x] inserts x
dsb("Hello .[x]!")

# elements in ... are collapsed with "" (default)
dsb("Hello .[x[1]], ",
    "how is .[x[2]] doing?")

# Splitting a comma separated string
# The mechanism is explained later
dsb("/J. Mills, David, Agnes, Dr Strong")

# Nota: this is equivalent to (explained later)
dsb("{', *'S ! J. Mills, David, Agnes, Dr Strong}")

#
# Applying low level operations to strings
#

# Two main syntax:

# A) expression evaluation
# .[operation ? x]
#             | |
#             |  \-> the expression to be evaluated
#              \-> ? means that the expression will be evaluated

# B) verbatim
# .[operation ! x]
#             | |
#             |  \-> the expression taken as verbatim (here 'x')
#              \-> ! means that the expression is taken as verbatim

# operation: usually 'arg'op with op an operation code.

# Example: splitting
x = "hello dear"
dsb(".[' 's ? x]")
# x is split by ' '

dsb(".[' 's ! hello dear]")
# 'hello dear' is split by ' '
# had we used ?, there would have been an error

# By default, the full string is nested in .[], so in that case no need to use .[]:
dsb("' 's ? x")
dsb("' 's ! hello dear")

# There are 35+ string operators
# Operators usually have a default value
# Operations can be chained by separating them with a comma

# Example: default of 's' is ' ' + chaining with collapse
dsb("s, ' my 'c ! hello dear")

#
# Nesting
#

# .[operations ! s1.[expr]s2]
#              |    |
#              |     \-> expr will be evaluated then added to the string
#               \-> nesting requires verbatim evaluation: '!'

dsb("The variables are: .[C ! x.[1:4]].")

# This one is ugly but it shows triple nesting
dsb("The variables are: .[ws, C ! .[2 times ! x.[1:4]].[','s, 4 each !  ,_sq]].")

#
# Splitting
#

# s: split with fixed pattern, default is ' '
dsb("s ! a b c")
dsb("' b 's !a b c")

# S: split with regex pattern, default is ',[ \t\n]*'
dsb("S !a, b, c")
dsb("'[[:punct:] ]+'S ! a! b; c")

#
# Collapsing
#

# c and C do the same, their default is different
# syntax: 's1||s2' with
# - s1 the string used for collapsing
# - s2 (optional) the string used for the last collapse

# c: default is ' '
dsb("c ? 1:3")

# C: default is ', || and '
dsb("C ? 1:3")

dsb("', || or 'c ? 1:4")

#
# Extraction
#

# x: extracts the first pattern
# X: extracts all patterns
# syntax: 'pattern'x
# Default is '[[:alnum:]]+'

x = "This years is... 2020"
dsb("x ? x")
dsb("X ? x")

dsb("'\\\\d+'x ? x")

#
# STRING FORMATTING ####
#

#
# u, U, title: uppercase first/all letters

# first letter
dsb("u ! julia mills")

# title case: split -> upper first letter -> collapse
dsb("title ! julia mills")

# upper all letters
dsb("U ! julia mills")

#
# L: lowercase

dsb("L ! JULIA MILLS")

#
# q, Q, bq: single, double, back quote

dsb("S, q, C ! Julia, David, Wilkins")
dsb("S, Q, C ! Julia, David, Wilkins")
dsb("S, bq, C ! Julia, David, Wilkins")

#
# format, Format: formats the string to fit the same length

# format: the right side is filled with blanks
# Format: the left side is filled with blanks

score = c(-10, 2050)
nm = c("Wilkins", "David")
dsb("Monopoly scores:\n.['\n'c ! - .[format ? nm]: .[Format ? score] US$]")

# OK that example may have been a bit too complex,
# let's make it simple:

dsb("Scores: .[format ? score]")
dsb("Names: .[Format ? nm]")

#
# w: white space normalization

# w: suppresses trimming white spaces + normalizes successive white spaces
# Add the following letters in any order to:
# - p: remove punctuation
# - d: remove digits
# - i: remove isolated characters
#
# W is a shorthand to wp.

dsb("w ! The   white  spaces are now clean.  ")

dsb("W ! I, really -- truly; love punctuation!!!")

# same: dsb("wp ! I, really -- truly; love punctuation!!!")

dsb("wd ! 1, 2, 12, a microphone check!")

dsb("wi ! 1, 2, 12, a microphone check!")

dsb("wdi ! 1, 2, 12, a microphone check!")

dsb("wpdi ! 1, 2, 12, a microphone check!")

#
# \%: applies sprintf formatting

dsb("pi = .['.2f'\% ? pi]")

#
# a: appends text on each item
# ar: appends text on the right of each item
# syntax: 's1|s2'a, adds s1 at the beginning and s2 at the end of the string
# It accepts the special values :1:, :i:, :I:, :a:, :A:
# These values create enumerations (only one such value is accepted)

# appending square brackets
dsb("'[|]'a, ' + 'c ! x.[1:4]")

# Enumerations
acad = dsb("/you like admin, you enjoy working on weekends, you really love emails")
dsb("Main reasons to pursue an academic career:\n .[':i:) 'a, C ? acad].")

#
# A: same as 'a' but adds at the begining/end of the full string (not on the elements)
# special values: :n:, :N:, give the number of elements

characters = dsb("/David, Wilkins, Dora, Agnes")
dsb("There are .[':N: characters: 'A, C ? characters].")

# Alternative with pluralization
dsb("There .[$is, N ? characters] character.[$s]: .[$enum].")


#
# stop: removes basic English stopwords
# the list is from the Snowball project:
#  http://snowball.tartarus.org/algorithms/english/stop.txt

dsb("stop, w ! It is a tale told by an idiot, full of sound and fury, signifying nothing.")

#
# k: keeps the first n characters
# syntax: nk: keeps the first n characters
#         'n|s'k: same + adds 's' at the end of shortened strings
#         'n||s'k: same but 's' counts in the n characters kept

words = dsb("/short, constitutional")
dsb("5k ? words")

dsb("'5|..'k ? words")

dsb("'5||..'k ? words")

#
# K: keeps the first n elements
# syntax: nK: keeps the first n elements
#         'n|s'K: same + adds the element 's' at the end
#         'n||s'K: same but 's' counts in the n elements kept
#
# Special values :rest: and :REST:, give the number of items dropped

bx = dsb("/Pessac Leognan, Saint Emilion, Marguaux, Saint Julien, Pauillac")
dsb("Bordeaux wines I like: .[3K, ', 'C ? bx].")

dsb("Bordeaux wines I like: .['3|etc..'K, ', 'C ? bx].")

dsb("Bordeaux wines I like: .['3||etc..'K, ', 'C ? bx].")

dsb("Bordeaux wines I like: .['3|and at least :REST: others'K, ', 'C ? bx].")

#
# Ko, KO: special operator which keeps the first n elements and adds "others"
# syntax: nKo
# KO gives the rest in letters

dsb("Bordeaux wines I like: .[4KO, C ? bx].")

#
# r: string replacement with fixed search
# R: string replacement, perl regular expressions
# syntax: 's'R: deletes the content in 's' (replaces with the empty string)
#         's1 => s2'R replaces s1 into s2

dsb("'e'r ! The letter e is deleted")

# adding a perl look-behind
dsb("'(?<! )e'R !The letter e is deleted")

dsb("'e => a'r !The letter e becomes a")

dsb("'([[:alpha:]]{3})[[:alpha:]]+ => \\\\1.'R ! Trimming the words")

# Alternative way with simple operations: split, shorten, collapse
dsb("s, '3|.'k, c ! Trimming the words")

#
# *, *c, **, **c: replication, replication + collapse
# syntax: n* or n*c
# ** is the same as * but uses "each" in the replication

dsb("N.[10*c ! o]!")

dsb("3*c ? 1:3")
dsb("3**c ? 1:3")

#
# d: replaces the items by the empty string
# -> useful in conditions

dsb("d!I am going to be annihilated")

#
# ELEMENT MANIPULATION ####
#

#
# D: removes the element completely
# -> useful in conditions

x = c("Destroy", "All")
dsb("D ? x")

x = dsb("/1, 12, 123, 1234, 123456, 1234567")
# we delete elements whose number of characters is lower or equal to 3
# => see later section CONDITIONS
dsb("@<=3(D) ? x")

#
# i, I: inserts an item
# syntax: 's1|s2'i: inserts s1 first and s2 last

characters = dsb("/David, Wilkins, Dora, Agnes, Trotwood")
dsb("'Heep|Spenlow'i, C ? characters")

#
# PLURALIZATION ####
#

# Two ways to enable pluralization:
# .[$ command]: means the plural refers to the length of the object
# .[# commands]: means the plural refers to a number
# You must start with a dollar sign: this signals pluralization

# Explanatory example
x = c("Eschyle", "Sophocle", "Euripide")
n = 37
dsb("The author.[$s, enum, have ? x] written .[#N ? n] play.[#s].")

x = "Laurent Berge"
n = 0
dsb("The author.[$s, enum, have ? x] written .[#N ? n] play.[#s].")

# How does it work?
# First is .[$s, enum, have ? x].
# The commands `s`, `enum` and `have` are applied to `x` which must come after a `?`
#    => there the plural (whether an s is added and how to conjugate the verb have) depends
#       on the **length** of the vector `x`
#
# Second comes .[#N ? n].
# The double dollar sign means that the command `N` will be applied to the **value** n.
# The value must come after the `?`
#
# Third is .[#s].
# The object to which `s` should be applied is missing (there is no `? n`).
# The default is to apply the command to the previous object. In this case,
#  this is `n`.

# Another similar example illustrating that we need not express the object several times:
x = c("Eschyle", "Sophocle", "Euripide")
dsb("The .[len ? x] classic author.[$s, are, enum].")


#
# CONDITIONS ####
#

# There are three types of conditions:
# - on the number of elements
# - on the number of characters
# - on patterns

# Conditions on the number of elements:
# - the syntax is: #<=3(true:false)
# - the operations listed in `true` will be applied to the full vector if it
#   contains 3 elements or less
# - the operations listed in `false` will be applied to the full vector if it
#   contains strictly more than 3 elements
# - the operation #(true:false) is a shorthand for #>1(true:false)

dsb("#>=5('+'c : ' + 'c) ? 1:8")
dsb("#>=5('+'c : ' + 'c) ? 8:10")

# Conditions on the number of characters
# - the syntax is: @<=3(true:false)
# - the operations listed in `true` will be applied to the elements with 3 characters or less
# - the operations listed in `false` will be applied to other elements
# - the operation @(true:false) is a shorthand for @>0(true:false)

x = c("short", "long sentence")
dsb("@<=5('*|*'a:x) ? x")

# Conditions on patterns:
# - the syntax is: <regex>(true:false)
# - regex should be a valid perl regular expression
# - the operations listed in `true` will be applied to the elements matching the regex
# - the operations listed in `false` will be applied to the other elements
# - use # first in the regex to trigger fixed search instead of regex-search
# - <#x^2>(true:false) will search for the fixed pattern 'x^2'

# Keeping only elements containing a digit
x = c("hello", "age = 25", "young", "762")
dsb("<\\\\d>(D), C ? x")

dsb("Elements with digits: .[<\\\\d>(:D), Q, C ? x].")


#
# ARGUMENTS FROM THE FRAME ####
#

# Arguments can be evaluated from the calling frame.
# Simply use backticks instead of quotes.

dollar = 6
reason = "glory"
dsb("Why do you develop packages? For .[`dollar`*c!$]?",
    "For money? No... for .[U,''s, c?reason]!", sep = "\n")




}
