% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/string_tools.R
\name{str_get}
\alias{str_get}
\title{Gets elements of a character vector}
\usage{
str_get(
  x,
  ...,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  or = FALSE,
  seq = FALSE,
  seq.unik = FALSE,
  pattern = NULL
)
}
\arguments{
\item{x}{A character vector.}

\item{...}{Character scalars representing the patterns to be found. By default they are (perl) regular-expressions.
Use ' & ' or ' | ' to chain patterns and combine their result logically (ex: '[\link{:alpha:}] & \\d' gets strings
containing both letters and numbers). You can negate by adding a \code{!} first (ex: \code{"!sepal$"} will
return \code{TRUE} for strings that do not end with \code{"sepal"}).
Add flags with the syntax 'flag1, flag2/pattern'. Available flags are: 'fixed', 'ignore', 'word', 'verbatim'.
Ex: "ignore/sepal" would get "Sepal.Length" (wouldn't be the case w/t 'ignore').
Shortcut: use the first letters of the flags. Ex: "if/dt[" would get "DT\link{i = 5}" (flags 'ignore' + 'fixed').
The flag 'verbatim' does not parse logical operations. For 'word', it adds word boundaries to the
pattern. See the documentation of this argument.}

\item{fixed}{Logical scalar, default is \code{FALSE}. Whether to trigger a fixed search instead of a
regular expression search (default).}

\item{ignore.case}{Logical scalar, default is \code{FALSE}. If \code{TRUE}, then case insensitive search is triggered.}

\item{word}{Logical scalar, default is \code{FALSE}. If \code{TRUE} then a) word boundaries are added to the pattern,
and b) patterns can be chained by separating them with a comma, they are combined with an OR logical operation.
Example: if \code{word = TRUE}, then pattern = "The, mountain" will select strings containing either the word
'The' or the word 'mountain'.}

\item{or}{Logical, default is \code{FALSE}. In the presence of two or more patterns,
whether to combine them with a logical "or" (the default is to combine them with a logical "and").}

\item{seq}{Logical, default is \code{FALSE}. The argument \code{pattern} accepts a vector of
patterns which are combined with an \code{and} by default. If \code{seq = TRUE}, then it is like
if \code{str_get} was called sequentially with its results stacked. See examples.}

\item{seq.unik}{Logical, default is \code{FALSE}. The argument \code{pattern} accepts a vector
of patterns which are combined with an \code{and} by default. If \code{seq.unik = TRUE}, then it is
like if \code{str_get} was called sequentially with its results stacked, and \code{unique()} was
applied in the end. See examples.}

\item{pattern}{(If provided, elements of \code{...} are ignored.) A character vector representing the
patterns to be found. By default a (perl) regular-expression search is triggered.
Use ' & ' or ' | ' to chain patterns and combine their result logically (ex: '[\link{:alpha:}] & \\d' gets strings
containing both letters and numbers). You can negate by adding a \code{!} first (ex: \code{"!sepal$"} will
return \code{TRUE} for strings that do not end with \code{"sepal"}).
Add flags with the syntax 'flag1, flag2/pattern'. Available flags are: 'fixed', 'ignore', 'word', 'verbatim'.
Ex: "ignore/sepal" would get "Sepal.Length" (wouldn't be the case w/t 'ignore').
Shortcut: use the first letters of the flags. Ex: "if/dt[" would get "DT\link{i = 5}" (flags 'ignore' + 'fixed').
The flag 'verbatim' does not parse logical operations. For 'word', it adds word boundaries to the
pattern. See the documentation of this argument.}
}
\value{
It always return a character vector.
}
\description{
Convenient way to get elements from a character vector.
}
\examples{

x = rownames(mtcars)

# find all Mazda cars
str_get(x, "Mazda")
# same with ignore case flag
str_get(x, "i/mazda")

# all cars containing a single digit (we use the 'word' flag)
str_get(x, "w/\\\\d")

# finds car names without numbers AND containing `u`
str_get(x, "!\\\\d", "u")
# equivalently
str_get(x, "!\\\\d & u")

# Stacks all Mazda and Volvo cars. Mazda first
str_get(x, "Mazda", "Volvo", seq = TRUE)

# Stacks all Mazda and Volvo cars. Volvo first
str_get(x, "Volvo", "Mazda", seq = TRUE)

# let's get the first word of each car name
car_first = str_op(x, "extract.first")
# we select car brands ending with 'a', then ending with 'i'
str_get(car_first, "a$", "i$", seq = TRUE)
# seq.unik is similar to seq but applies unique()
str_get(car_first, "a$", "i$", seq.unik = TRUE)

#
# flags
#

# you can combine the flags
x = dsb("/One, two, one... Two!, Microphone, check")
# regular
str_get(x, "one")
# ignore case
str_get(x, "i/one")
# + word boundaries
str_get(x, "iw/one")

# you can escape the meaning of ! with backslashes
str_get(x, "\\\\!")




}
