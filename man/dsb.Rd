% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/string_operations.R
\name{dsb}
\alias{dsb}
\alias{.dsb}
\title{Simple and powerful string manipulation with the dot square bracket operator}
\usage{
dsb(
  ...,
  frame = parent.frame(),
  sep = "",
  vectorize = FALSE,
  string_as_box = TRUE,
  collapse = NULL,
  help = NULL,
  use_DT = TRUE
)

.dsb(
  ...,
  frame = parent.frame(),
  sep = "",
  vectorize = FALSE,
  check = FALSE,
  string_as_box = FALSE,
  use_DT = FALSE
)
}
\arguments{
\item{...}{Character scalars that will be collapsed with the argument \code{sep}. You can
use \code{".[x]"} within each character string to insert the value of \code{x} in the string.
You can add string operations in each \code{".[]"} instance with the syntax \code{"'arg'op ? x"}
(resp. \code{"'arg'op ! x"}) to apply the operation \code{'op'} with the argument \code{'arg'} to \code{x}
(resp. the verbatim of \code{x}). Otherwise, what to say? Ah, nesting is enabled, and since
there's over 30 operators, it's a bit complicated to sort you out in this small space.
But type \code{dsb("--help")} to prompt an (almost) extensive help, or use the argument help.}

\item{frame}{An environment used to evaluate the variables in \code{".[]"}.}

\item{sep}{Character scalar, default is \code{""}. It is used to collapse all the elements in \code{...}.}

\item{vectorize}{Logical, default is \code{FALSE}. If \code{TRUE}, Further, elements in \code{...} are
NOT collapsed together, but instead vectorised.}

\item{string_as_box}{Logical, default is \code{TRUE}. Whether the original character strings
should be nested into a \code{".[]"}. If \code{TRUE}, then things like \code{dsb("S!one, two")}
are equivalent to \code{dsb(".[S!one, two]")} and hence create the vector \code{c("one", "two")}.}

\item{collapse}{Character scalar or \code{NULL} (default). If provided, the resulting
character vector will be collapsed into a character scalar using this value as a separator.

There are over 30 basic string operations, it supports pluralization, string operations can be
nested (it may be the most powerful feature), operators have sensible defaults.

See detailed help on the console with \code{dsb("--help")} or use the argument \code{help}. The real
help is in fact in the "Examples" section.}
}
\value{
It returns a character vector whose length depends on the elements and operations in \code{".[]"}.
}
\description{
Compactly performs many low level string operations. Advanced support for pluralization.
}
\section{Functions}{
\itemize{
\item \code{.dsb()}: Like \code{dsb} but without nice error messages (leads to slightly faster run times).

}}
\examples{

#
# BASIC USAGE ####
#

x = c("Romeo", "Juliet")

# .[x] inserts x
dsb("Hello .[x]!")

# elements in ... are collapsed with "" (default)
dsb("Hello .[x[1]], ",
    "how is .[x[2]] doing?")

# Splitting a comma separated string
# The mechanism is explained later
dsb("/J. Mills, David, Agnes, Dr Strong")

# Nota: this is equivalent to (explained later)
dsb("', *'S !J. Mills, David, Agnes, Dr Strong")

#
# Applying low level operations to strings
#

# Two main syntax:

# A) expression evaluation
# .[operation ? x]
#             | |
#             |  \-> the expression to be evaluated
#              \-> ? means that the expression will be evaluated

# B) verbatim
# .[operation ! x]
#             | |
#             |  \-> the expression taken as verbatim (here 'x')
#              \-> ! means that the expression is taken as verbatim

# operation: usually 'arg'op with op an operation code.

# Example: splitting
x = "hello dear"
dsb(".[' 's ? x]")
# x is split by ' '

dsb(".[' 's ! hello dear]")
# 'hello dear' is split by ' '
# had we used ?, there would have been an error

# By default, the full string is nested in .[], so in that case no need to use .[]:
dsb("' 's ? x")
dsb("' 's ! hello dear")

# There are 35+ string operators
# Operators usually have a default value
# Operations can be chained by separating them with a comma

# Example: default of 's' is ' ' + chaining with collapse
dsb("s, ' my 'c ! hello dear")

#
# Nesting
#

# .[operations ! s1.[expr]s2]
#              |    |
#              |     \-> expr will be evaluated then added to the string
#               \-> nesting requires verbatim evaluation: '!'

dsb("The variables are: .[C ! x.[1:4]].")

# This one is ugly but it shows triple nesting
dsb("The variables are: .[w, C ! .[2* ! x.[1:4]].[','s, 4** !  ,_sq]].")

#
# Splitting
#

# s: split with fixed pattern, default is ' '
dsb("s ! a b c")
dsb("' b 's !a b c")

# S: split with regex pattern, default is ',[ \t\n]*'
dsb("S !a, b, c")
dsb("'[[:punct:] ]+'S ! a! b; c")

#
# Collapsing
#

# c and C do the same, their default is different
# syntax: 's1||s2' with
# - s1 the string used for collapsing
# - s2 (optional) the string used for the last collapse

# c: default is ' '
dsb("c ? 1:3")

# C: default is ', || and '
dsb("C ? 1:3")

dsb("', || or 'c ? 1:4")

#
# Extraction
#

# x: extracts the first pattern
# X: extracts all patterns
# syntax: 'pattern'x
# Default is '[[:alnum:]]+'

x = "This years is... 2020"
dsb("x ? x")
dsb("X ? x")

dsb("'\\\\d+'x ? x")

#
# STRING FORMATTING ####
#

#
# u, U, title: uppercase first/all letters

# first letter
dsb("u ! julia mills")

# title case: split -> upper first letter -> collapse
dsb("title ! julia mills")

# upper all letters
dsb("U ! julia mills")

#
# L: lowercase

dsb("L ! JULIA MILLS")

#
# q, Q, bq: single, double, back quote

dsb("S, q, C ! Julia, David, Wilkins")
dsb("S, Q, C ! Julia, David, Wilkins")
dsb("S, bq, C ! Julia, David, Wilkins")

#
# format, Format: formats the string to fit the same length

# format: the right side is filled with blanks
# Format: the left side is filled with blanks

score = c(-10, 2050)
nm = c("Wilkins", "David")
dsb("Monopoly scores:\n.['\n'c ! - .[format ? nm]: .[Format ? score] US$]")

# OK that example may have been a bit too complex,
# let's make it simple:

dsb("Scores: .[format ? score]")
dsb("Names: .[Format ? nm]")

#
# w: white space normalization

# w: suppresses trimming white spaces + normalizes successive white spaces
# Add the following letters in any order to:
# - p: remove punctuation
# - d: remove digits
# - i: remove isolated characters
#
# W is a shorthand to wp.

dsb("w ! The   white  spaces are now clean.  ")

dsb("W ! I, really -- truly; love punctuation!!!")

# same: dsb("wp ! I, really -- truly; love punctuation!!!")

dsb("wd ! 1, 2, 12, a microphone check!")

dsb("wi ! 1, 2, 12, a microphone check!")

dsb("wdi ! 1, 2, 12, a microphone check!")

dsb("wpdi ! 1, 2, 12, a microphone check!")

#
# \%: applies sprintf formatting

dsb("pi = .['.2f'\% ? pi]")

#
# a: appends text on each item
# ar: appends text on the right of each item
# syntax: 's1|s2'a, adds s1 at the beginning and s2 at the end of the string
# It accepts the special values :1:, :i:, :I:, :a:, :A:
# These values create enumerations (only one such value is accepted)

# appending square brackets
dsb("'[|]'a, ' + 'c ! x.[1:4]")

# Enumerations
acad = dsb("/you like admin, you enjoy working on weekends, you really love emails")
dsb("Main reasons to pursue an academic career:\n .[':i:) 'a, C ? acad].")

#
# A: same as 'a' but adds at the begining/end of the full string (not on the elements)
# special values: :n:, :N:, give the number of elements

characters = dsb("/David, Wilkins, Dora, Agnes")
dsb("There are .[':N: characters: 'A, C ? characters].")

# Alternative with pluralization
dsb("There .[$is, N ? characters] character.[$s]: .[$enum].")


#
# stop: removes basic English stopwords
# the list is from the Snowball project:
#  http://snowball.tartarus.org/algorithms/english/stop.txt

dsb("stop, w ! It is a tale told by an idiot, full of sound and fury, signifying nothing.")

#
# k: keeps the first n characters
# syntax: nk: keeps the first n characters
#         'n|s'k: same + adds 's' at the end of shortened strings
#         'n||s'k: same but 's' counts in the n characters kept

words = dsb("/short, constitutional")
dsb("5k ? words")

dsb("'5|..'k ? words")

dsb("'5||..'k ? words")

#
# K: keeps the first n elements
# syntax: nK: keeps the first n elements
#         'n|s'K: same + adds the element 's' at the end
#         'n||s'K: same but 's' counts in the n elements kept
#
# Special values :rest: and :REST:, give the number of items dropped

bx = dsb("/Pessac Leognan, Saint Emilion, Marguaux, Saint Julien, Pauillac")
dsb("Bordeaux wines I like: .[3K, ', 'C ? bx].")

dsb("Bordeaux wines I like: .['3|etc..'K, ', 'C ? bx].")

dsb("Bordeaux wines I like: .['3||etc..'K, ', 'C ? bx].")

dsb("Bordeaux wines I like: .['3|and at least :REST: others'K, ', 'C ? bx].")

#
# Ko, KO: special operator which keeps the first n elements and adds "others"
# syntax: nKo
# KO gives the rest in letters

dsb("Bordeaux wines I like: .[4KO, C ? bx].")

#
# r: string replacement with fixed search
# R: string replacement, perl regular expressions
# syntax: 's'R: deletes the content in 's' (replaces with the empty string)
#         's1 => s2'R replaces s1 into s2

dsb("'e'r ! The letter e is deleted")

# adding a perl look-behind
dsb("'(?<! )e'R !The letter e is deleted")

dsb("'e => a'r !The letter e becomes a")

dsb("'([[:alpha:]]{3})[[:alpha:]]+ => \\\\1.'R ! Trimming the words")

# Alternative way with simple operations: split, shorten, collapse
dsb("s, '3|.'k, c ! Trimming the words")

#
# *, *c, **, **c: replication, replication + collapse
# syntax: n* or n*c
# ** is the same as * but uses "each" in the replication

dsb("N.[10*c ! o]!")

dsb("3*c ? 1:3")
dsb("3**c ? 1:3")

#
# d: replaces the items by the empty string
# -> useful in conditions

dsb("d!I am going to be annihilated")

#
# ELEMENT MANIPULATION ####
#

#
# D: removes the element completely
# -> useful in conditions

x = c("Destroy", "All")
dsb("D ? x")

x = dsb("/1, 12, 123, 1234, 123456, 1234567")
# we delete elements whose number of characters is lower or equal to 3
# => see later section CONDITIONS
dsb("@<=3(D) ? x")

#
# i, I: inserts an item
# syntax: 's1|s2'i: inserts s1 first and s2 last

characters = dsb("/David, Wilkins, Dora, Agnes, Trotwood")
dsb("'Heep|Spenlow'i, C ? characters")

#
# PLURALIZATION ####
#

# Two ways to enable pluralization:
# .[$ command]: means the plural refers to the length of the object
# .[# commands]: means the plural refers to a number
# You must start with a dollar sign: this signals pluralization

# Explanatory example
x = c("Eschyle", "Sophocle", "Euripide")
n = 37
dsb("The author.[$s, enum, have ? x] written .[#N ? n] play.[#s].")

x = "Laurent Berge"
n = 0
dsb("The author.[$s, enum, have ? x] written .[#N ? n] play.[#s].")

# How does it work?
# First is .[$s, enum, have ? x].
# The commands `s`, `enum` and `have` are applied to `x` which must come after a `?`
#    => there the plural (whether an s is added and how to conjugate the verb have) depends
#       on the **length** of the vector `x`
#
# Second comes .[#N ? n].
# The double dollar sign means that the command `N` will be applied to the **value** n.
# The value must come after the `?`
#
# Third is .[#s].
# The object to which `s` should be applied is missing (there is no `? n`).
# The default is to apply the command to the previous object. In this case,
#  this is `n`.

# Another similar example illustrating that we need not express the object several times:
x = c("Eschyle", "Sophocle", "Euripide")
dsb("The .[$n ? x] classic author.[$s, are, enum].")


#
# CONDITIONS ####
#

# There are three types of conditions:
# - on the number of elements
# - on the number of characters
# - on patterns

# Conditions on the number of elements:
# - the syntax is: #<=3(true:false)
# - the operations listed in `true` will be applied to the full vector if it
#   contains 3 elements or less
# - the operations listed in `false` will be applied to the full vector if it
#   contains strictly more than 3 elements
# - the operation #(true:false) is a shorthand for #>1(true:false)

dsb("#>=5('+'c : ' + 'c) ? 1:8")
dsb("#>=5('+'c : ' + 'c) ? 8:10")

# Conditions on the number of characters
# - the syntax is: @<=3(true:false)
# - the operations listed in `true` will be applied to the elements with 3 characters or less
# - the operations listed in `false` will be applied to other elements
# - the operation @(true:false) is a shorthand for @>0(true:false)

x = c("short", "long sentence")
dsb("@<=5('*|*'a:x) ? x")

# Conditions on patterns:
# - the syntax is: <regex>(true:false)
# - regex should be a valid perl regular expression
# - the operations listed in `true` will be applied to the elements matching the regex
# - the operations listed in `false` will be applied to the other elements
# - use # first in the regex to trigger fixed search instead of regex-search
# - <#x^2>(true:false) will search for the fixed pattern 'x^2'

# Keeping only elements containing a digit
x = c("hello", "age = 25", "young", "762")
dsb("<\\\\d>(D), C ? x")

dsb("Elements with digits: .[<\\\\d>(:D), Q, C ? x].")


#
# ARGUMENTS FROM THE FRAME ####
#

# Arguments can be evaluated from the calling frame.
# Simply use backticks instead of quotes.

dollar = 6
reason = "glory"
dsb("Why do you develop packages? For .[`dollar`*c!$]?",
    "For money? No... for .[U,''s, c?reason]!", sep = "\n")





}
